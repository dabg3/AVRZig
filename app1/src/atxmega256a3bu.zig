// generated by https://github.com/ZigEmbeddedGroup/microzig/tree/main/tools/regz

const mmio = @import("mmio.zig");

pub const devices = struct {
    pub const ATxmega256A3BU = struct {
        pub const properties = struct {
            pub const family = "AVR XMEGA";
        };
        pub const peripherals = struct {
            pub const GPIO: *volatile types.peripherals.GPIO = @ptrFromInt(0x0);
            /// Fuses
            pub const FUSE: *volatile types.peripherals.FUSE.NVM_FUSES = @ptrFromInt(0x0);
            /// Lock Bits
            pub const LOCKBIT: *volatile types.peripherals.LOCKBIT.NVM_LOCKBITS = @ptrFromInt(0x0);
            /// Production Signatures
            pub const PROD_SIGNATURES: *volatile types.peripherals.SIGROW.NVM_PROD_SIGNATURES = @ptrFromInt(0x0);
            pub const VPORT0: *volatile types.peripherals.VPORT = @ptrFromInt(0x10);
            pub const VPORT1: *volatile types.peripherals.VPORT = @ptrFromInt(0x14);
            pub const VPORT2: *volatile types.peripherals.VPORT = @ptrFromInt(0x18);
            pub const VPORT3: *volatile types.peripherals.VPORT = @ptrFromInt(0x1c);
            /// On-Chip Debug System
            pub const OCD: *volatile types.peripherals.XOCD.OCD = @ptrFromInt(0x2e);
            pub const CPU: *volatile types.peripherals.CPU = @ptrFromInt(0x30);
            pub const CLK: *volatile types.peripherals.CLK = @ptrFromInt(0x40);
            pub const SLEEP: *volatile types.peripherals.SLEEP = @ptrFromInt(0x48);
            pub const OSC: *volatile types.peripherals.OSC = @ptrFromInt(0x50);
            pub const DFLLRC32M: *volatile types.peripherals.DFLL = @ptrFromInt(0x60);
            pub const DFLLRC2M: *volatile types.peripherals.DFLL = @ptrFromInt(0x68);
            pub const PR: *volatile types.peripherals.PR = @ptrFromInt(0x70);
            pub const RST: *volatile types.peripherals.RST = @ptrFromInt(0x78);
            pub const WDT: *volatile types.peripherals.WDT = @ptrFromInt(0x80);
            pub const MCU: *volatile types.peripherals.MCU = @ptrFromInt(0x90);
            pub const PMIC: *volatile types.peripherals.PMIC = @ptrFromInt(0xa0);
            pub const PORTCFG: *volatile types.peripherals.PORTCFG = @ptrFromInt(0xb0);
            pub const AES: *volatile types.peripherals.AES = @ptrFromInt(0xc0);
            pub const CRC: *volatile types.peripherals.CRC = @ptrFromInt(0xd0);
            pub const VBAT: *volatile types.peripherals.VBAT = @ptrFromInt(0xf0);
            /// DMA Controller
            pub const DMA: *volatile types.peripherals.DMA.DMA = @ptrFromInt(0x100);
            pub const EVSYS: *volatile types.peripherals.EVSYS = @ptrFromInt(0x180);
            pub const NVM: *volatile types.peripherals.NVM = @ptrFromInt(0x1c0);
            /// Analog-to-Digital Converter
            pub const ADCA: *volatile types.peripherals.ADC.ADC = @ptrFromInt(0x200);
            /// Analog-to-Digital Converter
            pub const ADCB: *volatile types.peripherals.ADC.ADC = @ptrFromInt(0x240);
            pub const DACB: *volatile types.peripherals.DAC = @ptrFromInt(0x320);
            pub const ACA: *volatile types.peripherals.AC = @ptrFromInt(0x380);
            pub const ACB: *volatile types.peripherals.AC = @ptrFromInt(0x390);
            pub const RTC32: *volatile types.peripherals.RTC32 = @ptrFromInt(0x420);
            /// Two-Wire Interface
            pub const TWIC: *volatile types.peripherals.TWI.TWI = @ptrFromInt(0x480);
            /// Two-Wire Interface
            pub const TWIE: *volatile types.peripherals.TWI.TWI = @ptrFromInt(0x4a0);
            /// Universal Serial Bus
            pub const USB: *volatile types.peripherals.USB.USB = @ptrFromInt(0x4c0);
            pub const PORTA: *volatile types.peripherals.PORT = @ptrFromInt(0x600);
            pub const PORTB: *volatile types.peripherals.PORT = @ptrFromInt(0x620);
            pub const PORTC: *volatile types.peripherals.PORT = @ptrFromInt(0x640);
            pub const PORTD: *volatile types.peripherals.PORT = @ptrFromInt(0x660);
            pub const PORTE: *volatile types.peripherals.PORT = @ptrFromInt(0x680);
            pub const PORTF: *volatile types.peripherals.PORT = @ptrFromInt(0x6a0);
            pub const PORTR: *volatile types.peripherals.PORT = @ptrFromInt(0x7e0);
            /// 16-bit Timer/Counter 0
            pub const TCC0: *volatile types.peripherals.TC.TC0 = @ptrFromInt(0x800);
            pub const TCC2: *volatile types.peripherals.TC2 = @ptrFromInt(0x800);
            /// 16-bit Timer/Counter 1
            pub const TCC1: *volatile types.peripherals.TC.TC1 = @ptrFromInt(0x840);
            pub const AWEXC: *volatile types.peripherals.AWEX = @ptrFromInt(0x880);
            pub const HIRESC: *volatile types.peripherals.HIRES = @ptrFromInt(0x890);
            pub const USARTC0: *volatile types.peripherals.USART = @ptrFromInt(0x8a0);
            pub const USARTC1: *volatile types.peripherals.USART = @ptrFromInt(0x8b0);
            pub const SPIC: *volatile types.peripherals.SPI = @ptrFromInt(0x8c0);
            pub const IRCOM: *volatile types.peripherals.IRCOM = @ptrFromInt(0x8f8);
            /// 16-bit Timer/Counter 0
            pub const TCD0: *volatile types.peripherals.TC.TC0 = @ptrFromInt(0x900);
            pub const TCD2: *volatile types.peripherals.TC2 = @ptrFromInt(0x900);
            /// 16-bit Timer/Counter 1
            pub const TCD1: *volatile types.peripherals.TC.TC1 = @ptrFromInt(0x940);
            pub const HIRESD: *volatile types.peripherals.HIRES = @ptrFromInt(0x990);
            pub const USARTD0: *volatile types.peripherals.USART = @ptrFromInt(0x9a0);
            pub const USARTD1: *volatile types.peripherals.USART = @ptrFromInt(0x9b0);
            pub const SPID: *volatile types.peripherals.SPI = @ptrFromInt(0x9c0);
            /// 16-bit Timer/Counter 0
            pub const TCE0: *volatile types.peripherals.TC.TC0 = @ptrFromInt(0xa00);
            pub const TCE2: *volatile types.peripherals.TC2 = @ptrFromInt(0xa00);
            /// 16-bit Timer/Counter 1
            pub const TCE1: *volatile types.peripherals.TC.TC1 = @ptrFromInt(0xa40);
            pub const AWEXE: *volatile types.peripherals.AWEX = @ptrFromInt(0xa80);
            pub const HIRESE: *volatile types.peripherals.HIRES = @ptrFromInt(0xa90);
            pub const USARTE0: *volatile types.peripherals.USART = @ptrFromInt(0xaa0);
            /// 16-bit Timer/Counter 0
            pub const TCF0: *volatile types.peripherals.TC.TC0 = @ptrFromInt(0xb00);
            pub const TCF2: *volatile types.peripherals.TC2 = @ptrFromInt(0xb00);
            pub const HIRESF: *volatile types.peripherals.HIRES = @ptrFromInt(0xb90);
            pub const USARTF0: *volatile types.peripherals.USART = @ptrFromInt(0xba0);
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        pub const AC = extern struct {
            /// Hysteresis mode selection
            pub const AC_HYSMODE = enum(u2) {
                /// No hysteresis
                NO = 0x0,
                /// Small hysteresis
                SMALL = 0x1,
                /// Large hysteresis
                LARGE = 0x2,
                _,
            };

            /// Interrupt level
            pub const AC_INTLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Interrupt mode
            pub const AC_INTMODE = enum(u2) {
                /// Interrupt on both edges
                BOTHEDGES = 0x0,
                /// Interrupt on falling edge
                FALLING = 0x2,
                /// Interrupt on rising edge
                RISING = 0x3,
                _,
            };

            /// Negative input multiplexer selection
            pub const AC_MUXNEG = enum(u3) {
                /// Pin 0
                PIN0 = 0x0,
                /// Pin 1
                PIN1 = 0x1,
                /// Pin 3
                PIN3 = 0x2,
                /// Pin 5
                PIN5 = 0x3,
                /// Pin 7
                PIN7 = 0x4,
                /// DAC output
                DAC = 0x5,
                /// Bandgap Reference
                BANDGAP = 0x6,
                /// Internal voltage scaler
                SCALER = 0x7,
            };

            /// Positive input multiplexer selection
            pub const AC_MUXPOS = enum(u3) {
                /// Pin 0
                PIN0 = 0x0,
                /// Pin 1
                PIN1 = 0x1,
                /// Pin 2
                PIN2 = 0x2,
                /// Pin 3
                PIN3 = 0x3,
                /// Pin 4
                PIN4 = 0x4,
                /// Pin 5
                PIN5 = 0x5,
                /// Pin 6
                PIN6 = 0x6,
                /// DAC output
                DAC = 0x7,
            };

            /// Window interrupt level
            pub const AC_WINTLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low priority
                LO = 0x1,
                /// Medium priority
                MED = 0x2,
                /// High priority
                HI = 0x3,
            };

            /// Windows interrupt mode
            pub const AC_WINTMODE = enum(u2) {
                /// Interrupt on above window
                ABOVE = 0x0,
                /// Interrupt on inside window
                INSIDE = 0x1,
                /// Interrupt on below window
                BELOW = 0x2,
                /// Interrupt on outside window
                OUTSIDE = 0x3,
            };

            /// Window mode state
            pub const AC_WSTATE = enum(u2) {
                /// Signal above window
                ABOVE = 0x0,
                /// Signal inside window
                INSIDE = 0x1,
                /// Signal below window
                BELOW = 0x2,
                _,
            };

            /// Analog Comparator 0 Control
            AC0CTRL: mmio.Mmio(packed struct(u8) {
                /// Enable
                ENABLE: u1,
                /// Hysteresis Mode
                HYSMODE: AC_HYSMODE,
                /// High-speed Mode
                HSMODE: u1,
                /// Interrupt Level
                INTLVL: AC_INTLVL,
                /// Interrupt Mode
                INTMODE: AC_INTMODE,
            }),
            /// Analog Comparator 1 Control
            AC1CTRL: mmio.Mmio(packed struct(u8) {
                /// Enable
                ENABLE: u1,
                /// Hysteresis Mode
                HYSMODE: AC_HYSMODE,
                /// High-speed Mode
                HSMODE: u1,
                /// Interrupt Level
                INTLVL: AC_INTLVL,
                /// Interrupt Mode
                INTMODE: AC_INTMODE,
            }),
            /// Analog Comparator 0 MUX Control
            AC0MUXCTRL: mmio.Mmio(packed struct(u8) {
                /// MUX Negative Input
                MUXNEG: AC_MUXNEG,
                /// MUX Positive Input
                MUXPOS: AC_MUXPOS,
                padding: u2,
            }),
            /// Analog Comparator 1 MUX Control
            AC1MUXCTRL: mmio.Mmio(packed struct(u8) {
                /// MUX Negative Input
                MUXNEG: AC_MUXNEG,
                /// MUX Positive Input
                MUXPOS: AC_MUXPOS,
                padding: u2,
            }),
            /// Control Register A
            CTRLA: mmio.Mmio(packed struct(u8) {
                /// Analog Comparator 0 Output Enable
                AC0OUT: u1,
                /// Analog Comparator 1 Output Enable
                AC1OUT: u1,
                padding: u6,
            }),
            /// Control Register B
            CTRLB: mmio.Mmio(packed struct(u8) {
                /// VCC Voltage Scaler Factor
                SCALEFAC: u6,
                padding: u2,
            }),
            /// Window Mode Control
            WINCTRL: mmio.Mmio(packed struct(u8) {
                /// Window Interrupt Level
                WINTLVL: AC_WINTLVL,
                /// Window Interrupt Mode
                WINTMODE: AC_WINTMODE,
                /// Window Mode Enable
                WEN: u1,
                padding: u3,
            }),
            /// Status
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Analog Comparator 0 Interrupt Flag
                AC0IF: u1,
                /// Analog Comparator 1 Interrupt Flag
                AC1IF: u1,
                /// Window Mode Interrupt Flag
                WIF: u1,
                reserved4: u1,
                /// Analog Comparator 0 State
                AC0STATE: u1,
                /// Analog Comparator 1 State
                AC1STATE: u1,
                /// Window Mode State
                WSTATE: AC_WSTATE,
            }),
        };

        pub const ADC = struct {
            /// Gain factor
            pub const ADC_CH_GAIN = enum(u3) {
                /// 1x gain
                @"1X" = 0x0,
                /// 2x gain
                @"2X" = 0x1,
                /// 4x gain
                @"4X" = 0x2,
                /// 8x gain
                @"8X" = 0x3,
                /// 16x gain
                @"16X" = 0x4,
                /// 32x gain
                @"32X" = 0x5,
                /// 64x gain
                @"64X" = 0x6,
                /// x/2 gain
                DIV2 = 0x7,
            };

            /// Input mode
            pub const ADC_CH_INPUTMODE = enum(u2) {
                /// Internal inputs, no gain
                INTERNAL = 0x0,
                /// Single-ended input, no gain
                SINGLEENDED = 0x1,
                /// Differential input, no gain
                DIFF = 0x2,
                /// Differential input, with gain
                DIFFWGAIN = 0x3,
            };

            /// Interrupt level
            pub const ADC_CH_INTLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Interrupt mode
            pub const ADC_CH_INTMODE = enum(u2) {
                /// Interrupt on conversion complete
                COMPLETE = 0x0,
                /// Interrupt on result below compare value
                BELOW = 0x1,
                /// Interrupt on result above compare value
                ABOVE = 0x3,
                _,
            };

            /// Internal input multiplexer selections
            pub const ADC_CH_MUXINT = enum(u2) {
                /// Temperature Reference
                TEMP = 0x0,
                /// Bandgap Reference
                BANDGAP = 0x1,
                /// 1/10 scaled VCC
                SCALEDVCC = 0x2,
                /// DAC output
                DAC = 0x3,
            };

            /// Negative input multiplexer selection
            pub const ADC_CH_MUXNEG = enum(u3) {
                /// Input pin 0 (Input Mode = 2)
                PIN0 = 0x0,
                /// Input pin 1 (Input Mode = 2)
                PIN1 = 0x1,
                /// Input pin 2 (Input Mode = 2)
                PIN2 = 0x2,
                /// Input pin 3 (Input Mode = 2)
                PIN3 = 0x3,
                /// Internal Ground (Input Mode = 3)
                INTGND_MODE4 = 0x4,
                /// PAD Ground (Input Mode = 2)
                GND_MODE3 = 0x5,
                /// Internal Ground (Input Mode = 2)
                INTGND_MODE3 = 0x7,
                _,
            };

            /// Positive input multiplexer selection
            pub const ADC_CH_MUXPOS = enum(u4) {
                /// Input pin 0
                PIN0 = 0x0,
                /// Input pin 1
                PIN1 = 0x1,
                /// Input pin 2
                PIN2 = 0x2,
                /// Input pin 3
                PIN3 = 0x3,
                /// Input pin 4
                PIN4 = 0x4,
                /// Input pin 5
                PIN5 = 0x5,
                /// Input pin 6
                PIN6 = 0x6,
                /// Input pin 7
                PIN7 = 0x7,
                /// Input pin 8
                PIN8 = 0x8,
                /// Input pin 9
                PIN9 = 0x9,
                /// Input pin 10
                PIN10 = 0xa,
                /// Input pin 11
                PIN11 = 0xb,
                /// Input pin 12
                PIN12 = 0xc,
                /// Input pin 13
                PIN13 = 0xd,
                /// Input pin 14
                PIN14 = 0xe,
                /// Input pin 15
                PIN15 = 0xf,
            };

            /// Current Limitation Mode
            pub const ADC_CURRLIMIT = enum(u2) {
                /// No limit
                NO = 0x0,
                /// Low current limit, max. sampling rate 1.5MSPS
                LOW = 0x1,
                /// Medium current limit, max. sampling rate 1MSPS
                MED = 0x2,
                /// High current limit, max. sampling rate 0.5MSPS
                HIGH = 0x3,
            };

            /// DMA request selection
            pub const ADC_DMASEL = enum(u2) {
                /// Combined DMA request OFF
                OFF = 0x0,
                /// ADC Channel 0 or 1
                CH01 = 0x1,
                /// ADC Channel 0 or 1 or 2
                CH012 = 0x2,
                /// ADC Channel 0 or 1 or 2 or 3
                CH0123 = 0x3,
            };

            /// Event action selection
            pub const ADC_EVACT = enum(u3) {
                /// No event action
                NONE = 0x0,
                /// First event triggers channel 0
                CH0 = 0x1,
                /// First two events trigger channel 0,1
                CH01 = 0x2,
                /// First three events trigger channel 0,1,2
                CH012 = 0x3,
                /// Events trigger channel 0,1,2,3
                CH0123 = 0x4,
                /// First event triggers sweep
                SWEEP = 0x5,
                /// The ADC is flushed and restarted for accurate timing
                SYNCSWEEP = 0x6,
                _,
            };

            /// Event channel input selection
            pub const ADC_EVSEL = enum(u3) {
                /// Event Channel 0,1,2,3
                @"0123" = 0x0,
                /// Event Channel 1,2,3,4
                @"1234" = 0x1,
                /// Event Channel 2,3,4,5
                @"2345" = 0x2,
                /// Event Channel 3,4,5,6
                @"3456" = 0x3,
                /// Event Channel 4,5,6,7
                @"4567" = 0x4,
                /// Event Channel 5,6,7
                @"567" = 0x5,
                /// Event Channel 6,7
                @"67" = 0x6,
                /// Event Channel 7
                @"7" = 0x7,
            };

            /// Clock prescaler
            pub const ADC_PRESCALER = enum(u3) {
                /// Divide clock by 4
                DIV4 = 0x0,
                /// Divide clock by 8
                DIV8 = 0x1,
                /// Divide clock by 16
                DIV16 = 0x2,
                /// Divide clock by 32
                DIV32 = 0x3,
                /// Divide clock by 64
                DIV64 = 0x4,
                /// Divide clock by 128
                DIV128 = 0x5,
                /// Divide clock by 256
                DIV256 = 0x6,
                /// Divide clock by 512
                DIV512 = 0x7,
            };

            /// Voltage reference selection
            pub const ADC_REFSEL = enum(u3) {
                /// Internal 1V
                INT1V = 0x0,
                /// Internal VCC / 1.6
                INTVCC = 0x1,
                /// External reference on PORT A
                AREFA = 0x2,
                /// External reference on PORT B
                AREFB = 0x3,
                /// Internal VCC / 2
                INTVCC2 = 0x4,
                _,
            };

            /// Conversion result resolution
            pub const ADC_RESOLUTION = enum(u2) {
                /// 12-bit right-adjusted result
                @"12BIT" = 0x0,
                /// 8-bit right-adjusted result
                @"8BIT" = 0x2,
                /// 12-bit left-adjusted result
                LEFT12BIT = 0x3,
                _,
            };

            /// Channel sweep selection
            pub const ADC_SWEEP = enum(u2) {
                /// ADC Channel 0
                @"0" = 0x0,
                /// ADC Channel 0,1
                @"01" = 0x1,
                /// ADC Channel 0,1,2
                @"012" = 0x2,
                /// ADC Channel 0,1,2,3
                @"0123" = 0x3,
            };

            /// Analog-to-Digital Converter
            pub const ADC = extern struct {
                /// Control Register A
                CTRLA: mmio.Mmio(packed struct(u8) {
                    /// Enable ADC
                    ENABLE: u1,
                    /// Flush Pipeline
                    FLUSH: u1,
                    /// Channel 0 Start Conversion
                    CH0START: u1,
                    /// Channel 1 Start Conversion
                    CH1START: u1,
                    /// Channel 2 Start Conversion
                    CH2START: u1,
                    /// Channel 3 Start Conversion
                    CH3START: u1,
                    padding: u2,
                }),
                /// Control Register B
                CTRLB: mmio.Mmio(packed struct(u8) {
                    reserved3: u3,
                    /// Free Running Mode Enable
                    FREERUN: u1,
                    /// Conversion Mode
                    CONMODE: u1,
                    reserved7: u2,
                    /// Gain Stage Impedance Mode
                    IMPMODE: u1,
                }),
                /// Reference Control
                REFCTRL: mmio.Mmio(packed struct(u8) {
                    /// Temperature Reference Enable
                    TEMPREF: u1,
                    /// Bandgap enable
                    BANDGAP: u1,
                    padding: u6,
                }),
                /// Event Control
                EVCTRL: u8,
                /// Clock Prescaler
                PRESCALER: u8,
                reserved6: [1]u8,
                /// Interrupt Flags
                INTFLAGS: mmio.Mmio(packed struct(u8) {
                    /// Channel 0 Interrupt Flag
                    CH0IF: u1,
                    /// Channel 1 Interrupt Flag
                    CH1IF: u1,
                    /// Channel 2 Interrupt Flag
                    CH2IF: u1,
                    /// Channel 3 Interrupt Flag
                    CH3IF: u1,
                    padding: u4,
                }),
                /// Temporary Register
                TEMP: u8,
                reserved12: [4]u8,
                /// Calibration Value
                CAL: u16,
                reserved16: [2]u8,
                /// Channel 0 Result
                CH0RES: u16,
                /// Channel 1 Result
                CH1RES: u16,
                /// Channel 2 Result
                CH2RES: u16,
                /// Channel 3 Result
                CH3RES: u16,
                /// Compare Value
                CMP: u16,
                padding: [38]u8,
            };

            /// ADC Channel
            pub const ADC_CH = extern struct {
                /// Control Register
                CTRL: mmio.Mmio(packed struct(u8) {
                    reserved7: u7,
                    /// Channel Start Conversion
                    START: u1,
                }),
                /// MUX Control
                MUXCTRL: u8,
                /// Channel Interrupt Control Register
                INTCTRL: u8,
                /// Interrupt Flags
                INTFLAGS: mmio.Mmio(packed struct(u8) {
                    /// Channel Interrupt Flag
                    CHIF: u1,
                    padding: u7,
                }),
                /// Channel Result
                RES: u16,
                /// Input Channel Scan
                SCAN: mmio.Mmio(packed struct(u8) {
                    /// Number of Channels included in scan
                    SCANNUM: u4,
                    /// Positive MUX setting offset
                    OFFSET: u4,
                }),
                padding: [1]u8,
            };
        };

        pub const AES = extern struct {
            /// Interrupt level
            pub const AES_INTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// AES Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                reserved2: u2,
                /// State XOR Load Enable
                XOR: u1,
                reserved4: u1,
                /// Decryption / Direction
                DECRYPT: u1,
                /// AES Software Reset
                RESET: u1,
                /// Auto Start Trigger
                AUTO: u1,
                /// Start/Run
                START: u1,
            }),
            /// AES Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// State Ready Interrupt Flag
                SRIF: u1,
                reserved7: u6,
                /// AES Error
                ERROR: u1,
            }),
            /// AES State Register
            STATE: u8,
            /// AES Key Register
            KEY: u8,
            /// AES Interrupt Control Register
            INTCTRL: mmio.Mmio(packed struct(u8) {
                /// Interrupt level
                INTLVL: AES_INTLVL,
                padding: u6,
            }),
        };

        pub const AWEX = extern struct {
            /// Fault Detect Action
            pub const AWEX_FDACT = enum(u2) {
                /// No Fault Protection
                NONE = 0x0,
                /// Clear Output Enable Bits
                CLEAROE = 0x1,
                /// Clear I/O Port Direction Bits
                CLEARDIR = 0x3,
                _,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Dead Time Insertion Compare Channel A Enable
                DTICCAEN: u1,
                /// Dead Time Insertion Compare Channel B Enable
                DTICCBEN: u1,
                /// Dead Time Insertion Compare Channel C Enable
                DTICCCEN: u1,
                /// Dead Time Insertion Compare Channel D Enable
                DTICCDEN: u1,
                /// Common Waveform Channel Mode
                CWCM: u1,
                /// Pattern Generation Mode
                PGM: u1,
                padding: u2,
            }),
            reserved2: [1]u8,
            /// Fault Detection Event Mask
            FDEMASK: u8,
            /// Fault Detection Control Register
            FDCTRL: mmio.Mmio(packed struct(u8) {
                /// Fault Detect Action
                FDACT: AWEX_FDACT,
                /// Fault Detect Mode
                FDMODE: u1,
                reserved4: u1,
                /// Fault Detect on Disable Break Disable
                FDDBD: u1,
                padding: u3,
            }),
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Dead Time Low Side Buffer Valid
                DTLSBUFV: u1,
                /// Dead Time High Side Buffer Valid
                DTHSBUFV: u1,
                /// Fault Detect Flag
                FDF: u1,
                padding: u5,
            }),
            /// Status Set Register
            STATUSSET: mmio.Mmio(packed struct(u8) {
                /// Dead Time Low Side Buffer Valid
                DTLSBUFV: u1,
                /// Dead Time High Side Buffer Valid
                DTHSBUFV: u1,
                /// Fault Detect Flag
                FDF: u1,
                padding: u5,
            }),
            /// Dead Time Both Sides
            DTBOTH: u8,
            /// Dead Time Both Sides Buffer
            DTBOTHBUF: u8,
            /// Dead Time Low Side
            DTLS: u8,
            /// Dead Time High Side
            DTHS: u8,
            /// Dead Time Low Side Buffer
            DTLSBUF: u8,
            /// Dead Time High Side Buffer
            DTHSBUF: u8,
            /// Output Override Enable
            OUTOVEN: u8,
        };

        pub const CLK = extern struct {
            /// Prescaler A Division Factor
            pub const CLK_PSADIV = enum(u5) {
                /// Divide by 1
                @"1" = 0x0,
                /// Divide by 2
                @"2" = 0x1,
                /// Divide by 4
                @"4" = 0x3,
                /// Divide by 8
                @"8" = 0x5,
                /// Divide by 16
                @"16" = 0x7,
                /// Divide by 32
                @"32" = 0x9,
                /// Divide by 64
                @"64" = 0xb,
                /// Divide by 128
                @"128" = 0xd,
                /// Divide by 256
                @"256" = 0xf,
                /// Divide by 512
                @"512" = 0x11,
                _,
            };

            /// Prescaler B and C Division Factor
            pub const CLK_PSBCDIV = enum(u2) {
                /// Divide B by 1 and C by 1
                @"1_1" = 0x0,
                /// Divide B by 1 and C by 2
                @"1_2" = 0x1,
                /// Divide B by 4 and C by 1
                @"4_1" = 0x2,
                /// Divide B by 2 and C by 2
                @"2_2" = 0x3,
            };

            /// RTC Clock Source
            pub const CLK_RTCSRC = enum(u3) {
                /// 1.024 kHz from internal 32kHz ULP
                ULP = 0x0,
                /// 1.024 kHz from 32.768 kHz crystal oscillator on TOSC
                TOSC = 0x1,
                /// 1.024 kHz from internal 32.768 kHz RC oscillator
                RCOSC = 0x2,
                /// 32.768 kHz from 32.768 kHz crystal oscillator on TOSC
                TOSC32 = 0x5,
                /// 32.768 kHz from internal 32.768 kHz RC oscillator
                RCOSC32 = 0x6,
                /// External Clock from TOSC1
                EXTCLK = 0x7,
                _,
            };

            /// System Clock Selection
            pub const CLK_SCLKSEL = enum(u3) {
                /// Internal 2 MHz RC Oscillator
                RC2M = 0x0,
                /// Internal 32 MHz RC Oscillator
                RC32M = 0x1,
                /// Internal 32.768 kHz RC Oscillator
                RC32K = 0x2,
                /// External Crystal Oscillator or Clock
                XOSC = 0x3,
                /// Phase Locked Loop
                PLL = 0x4,
                _,
            };

            /// USB Prescaler Division Factor
            pub const CLK_USBPSDIV = enum(u3) {
                /// Divide by 1
                @"1" = 0x0,
                /// Divide by 2
                @"2" = 0x1,
                /// Divide by 4
                @"4" = 0x2,
                /// Divide by 8
                @"8" = 0x3,
                /// Divide by 16
                @"16" = 0x4,
                /// Divide by 32
                @"32" = 0x5,
                _,
            };

            /// USB Clock Source
            pub const CLK_USBSRC = enum(u1) {
                /// PLL
                PLL = 0x0,
                /// Internal 32 MHz RC Oscillator
                RC32M = 0x1,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// System Clock Selection
                SCLKSEL: CLK_SCLKSEL,
                padding: u5,
            }),
            /// Prescaler Control Register
            PSCTRL: mmio.Mmio(packed struct(u8) {
                /// Prescaler B and C Division factor
                PSBCDIV: CLK_PSBCDIV,
                /// Prescaler A Division Factor
                PSADIV: CLK_PSADIV,
                padding: u1,
            }),
            /// Lock register
            LOCK: mmio.Mmio(packed struct(u8) {
                /// Clock System Lock
                LOCK: u1,
                padding: u7,
            }),
            /// RTC Control Register
            RTCCTRL: mmio.Mmio(packed struct(u8) {
                /// Clock Source Enable
                RTCEN: u1,
                /// Clock Source
                RTCSRC: CLK_RTCSRC,
                padding: u4,
            }),
            /// USB Control Register
            USBCTRL: mmio.Mmio(packed struct(u8) {
                /// Clock Source Enable
                USBSEN: u1,
                /// Clock Source
                USBSRC: CLK_USBSRC,
                /// Prescaler Division Factor
                USBPSDIV: CLK_USBPSDIV,
                padding: u3,
            }),
        };

        pub const CPU = extern struct {
            /// CCP signatures
            pub const CCP = enum(u8) {
                /// SPM Instruction Protection
                SPM = 0x9d,
                /// IO Register Protection
                IOREG = 0xd8,
                _,
            };

            reserved4: [4]u8,
            /// Configuration Change Protection
            CCP: mmio.Mmio(packed struct(u8) {
                /// CCP signature
                CCP: CCP,
            }),
            reserved8: [3]u8,
            /// Ramp D
            RAMPD: u8,
            /// Ramp X
            RAMPX: u8,
            /// Ramp Y
            RAMPY: u8,
            /// Ramp Z
            RAMPZ: u8,
            /// Extended Indirect Jump
            EIND: u8,
            /// Stack Pointer Low
            SPL: u8,
            /// Stack Pointer High
            SPH: u8,
            /// Status Register
            SREG: mmio.Mmio(packed struct(u8) {
                /// Carry Flag
                C: u1,
                /// Zero Flag
                Z: u1,
                /// Negative Flag
                N: u1,
                /// Two's Complement Overflow Flag
                V: u1,
                /// N Exclusive Or V Flag
                S: u1,
                /// Half Carry Flag
                H: u1,
                /// Transfer Bit
                T: u1,
                /// Global Interrupt Enable Flag
                I: u1,
            }),
        };

        pub const CRC = extern struct {
            /// Reset
            pub const CRC_RESET = enum(u2) {
                /// No Reset
                NO = 0x0,
                /// Reset CRC with CHECKSUM to all zeros
                RESET0 = 0x2,
                /// Reset CRC with CHECKSUM to all ones
                RESET1 = 0x3,
                _,
            };

            /// Input Source
            pub const CRC_SOURCE = enum(u3) {
                /// Disabled
                DISABLE = 0x0,
                /// I/O Interface
                IO = 0x1,
                /// Flash
                FLASH = 0x2,
                /// DMAC Channel 0
                DMAC0 = 0x4,
                /// DMAC Channel 1
                DMAC1 = 0x5,
                /// DMAC Channel 2
                DMAC2 = 0x6,
                /// DMAC Channel 3
                DMAC3 = 0x7,
                _,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Input Source
                SOURCE: CRC_SOURCE,
                reserved5: u1,
                /// CRC Mode
                CRC32: u1,
                /// Reset
                RESET: CRC_RESET,
            }),
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Busy
                BUSY: u1,
                /// Zero detection
                ZERO: u1,
                padding: u6,
            }),
            reserved3: [1]u8,
            /// Data Input
            DATAIN: u8,
            /// Checksum byte 0
            CHECKSUM0: u8,
            /// Checksum byte 1
            CHECKSUM1: u8,
            /// Checksum byte 2
            CHECKSUM2: u8,
            /// Checksum byte 3
            CHECKSUM3: u8,
        };

        pub const DAC = extern struct {
            /// Output channel selection
            pub const DAC_CHSEL = enum(u2) {
                /// Single channel operation (Channel 0 only)
                SINGLE = 0x0,
                /// Single channel operation (Channel 1 only)
                SINGLE1 = 0x1,
                /// Dual channel operation (Channel 0 and channel 1)
                DUAL = 0x2,
                _,
            };

            /// Event channel selection
            pub const DAC_EVSEL = enum(u3) {
                /// Event Channel 0
                @"0" = 0x0,
                /// Event Channel 1
                @"1" = 0x1,
                /// Event Channel 2
                @"2" = 0x2,
                /// Event Channel 3
                @"3" = 0x3,
                /// Event Channel 4
                @"4" = 0x4,
                /// Event Channel 5
                @"5" = 0x5,
                /// Event Channel 6
                @"6" = 0x6,
                /// Event Channel 7
                @"7" = 0x7,
            };

            /// Reference voltage selection
            pub const DAC_REFSEL = enum(u2) {
                /// Internal 1V
                INT1V = 0x0,
                /// Analog supply voltage
                AVCC = 0x1,
                /// External reference on AREF on PORTA
                AREFA = 0x2,
                /// External reference on AREF on PORTB
                AREFB = 0x3,
            };

            /// Control Register A
            CTRLA: mmio.Mmio(packed struct(u8) {
                /// Enable
                ENABLE: u1,
                /// Low Power Mode
                LPMODE: u1,
                /// Channel 0 Output Enable
                CH0EN: u1,
                /// Channel 1 Output Enable
                CH1EN: u1,
                /// Internal Output Enable
                IDOEN: u1,
                padding: u3,
            }),
            /// Control Register B
            CTRLB: mmio.Mmio(packed struct(u8) {
                /// Channel 0 Event Trig Enable
                CH0TRIG: u1,
                /// Channel 1 Event Trig Enable
                CH1TRIG: u1,
                reserved5: u3,
                /// Channel Select
                CHSEL: DAC_CHSEL,
                padding: u1,
            }),
            /// Control Register C
            CTRLC: mmio.Mmio(packed struct(u8) {
                /// Left-adjust Result
                LEFTADJ: u1,
                reserved3: u2,
                /// Reference Select
                REFSEL: DAC_REFSEL,
                padding: u3,
            }),
            /// Event Input Control
            EVCTRL: mmio.Mmio(packed struct(u8) {
                /// Event Input Selection
                EVSEL: DAC_EVSEL,
                /// Separate Event Channel Input for Channel 1
                EVSPLIT: u1,
                padding: u4,
            }),
            reserved5: [1]u8,
            /// Status
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Channel 0 Data Register Empty
                CH0DRE: u1,
                /// Channel 1 Data Register Empty
                CH1DRE: u1,
                padding: u6,
            }),
            reserved8: [2]u8,
            /// Gain Calibration
            CH0GAINCAL: mmio.Mmio(packed struct(u8) {
                /// Gain Calibration
                CH0GAINCAL: u7,
                padding: u1,
            }),
            /// Offset Calibration
            CH0OFFSETCAL: mmio.Mmio(packed struct(u8) {
                /// Offset Calibration
                CH0OFFSETCAL: u7,
                padding: u1,
            }),
            /// Gain Calibration
            CH1GAINCAL: mmio.Mmio(packed struct(u8) {
                /// Gain Calibration
                CH1GAINCAL: u7,
                padding: u1,
            }),
            /// Offset Calibration
            CH1OFFSETCAL: mmio.Mmio(packed struct(u8) {
                /// Offset Calibration
                CH1OFFSETCAL: u7,
                padding: u1,
            }),
            reserved24: [12]u8,
            /// Channel 0 Data
            CH0DATA: u16,
            /// Channel 1 Data
            CH1DATA: u16,
        };

        pub const DFLL = extern struct {
            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// DFLL Enable
                ENABLE: u1,
                padding: u7,
            }),
            reserved2: [1]u8,
            /// Calibration Register A
            CALA: mmio.Mmio(packed struct(u8) {
                /// DFLL Calibration Value A
                CALL: u7,
                padding: u1,
            }),
            /// Calibration Register B
            CALB: mmio.Mmio(packed struct(u8) {
                /// DFLL Calibration Value B
                CALH: u6,
                padding: u2,
            }),
            /// Oscillator Compare Register 0
            COMP0: u8,
            /// Oscillator Compare Register 1
            COMP1: u8,
            /// Oscillator Compare Register 2
            COMP2: u8,
        };

        pub const DMA = struct {
            /// Burst mode
            pub const DMA_CH_BURSTLEN = enum(u2) {
                /// 1-byte burst mode
                @"1BYTE" = 0x0,
                /// 2-byte burst mode
                @"2BYTE" = 0x1,
                /// 4-byte burst mode
                @"4BYTE" = 0x2,
                /// 8-byte burst mode
                @"8BYTE" = 0x3,
            };

            /// Destination addressing mode
            pub const DMA_CH_DESTDIR = enum(u2) {
                /// Fixed
                FIXED = 0x0,
                /// Increment
                INC = 0x1,
                /// Decrement
                DEC = 0x2,
                _,
            };

            /// Destination address reload mode
            pub const DMA_CH_DESTRELOAD = enum(u2) {
                /// No reload
                NONE = 0x0,
                /// Reload at end of block
                BLOCK = 0x1,
                /// Reload at end of burst
                BURST = 0x2,
                /// Reload at end of transaction
                TRANSACTION = 0x3,
            };

            /// Interrupt level
            pub const DMA_CH_ERRINTLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Source addressing mode
            pub const DMA_CH_SRCDIR = enum(u2) {
                /// Fixed
                FIXED = 0x0,
                /// Increment
                INC = 0x1,
                /// Decrement
                DEC = 0x2,
                _,
            };

            /// Source address reload mode
            pub const DMA_CH_SRCRELOAD = enum(u2) {
                /// No reload
                NONE = 0x0,
                /// Reload at end of block
                BLOCK = 0x1,
                /// Reload at end of burst
                BURST = 0x2,
                /// Reload at end of transaction
                TRANSACTION = 0x3,
            };

            /// Transfer trigger source
            pub const DMA_CH_TRIGSRC = enum(u8) {
                /// Off software triggers only
                OFF = 0x0,
                /// Event System Channel 0
                EVSYS_CH0 = 0x1,
                /// Event System Channel 1
                EVSYS_CH1 = 0x2,
                /// Event System Channel 2
                EVSYS_CH2 = 0x3,
                /// AES
                AES = 0x4,
                /// ADCA Channel 0
                ADCA_CH0 = 0x10,
                /// ADCA Channel 1
                ADCA_CH1 = 0x11,
                /// ADCA Channel 2
                ADCA_CH2 = 0x12,
                /// ADCA Channel 3
                ADCA_CH3 = 0x13,
                /// ADCA Channel 0,1,2,3 combined
                ADCA_CH4 = 0x14,
                /// DACA Channel 0
                DACA_CH0 = 0x15,
                /// DACA Channel 1
                DACA_CH1 = 0x16,
                /// ADCB Channel 0
                ADCB_CH0 = 0x20,
                /// ADCB Channel 1
                ADCB_CH1 = 0x21,
                /// ADCB Channel 2
                ADCB_CH2 = 0x22,
                /// ADCB Channel 3
                ADCB_CH3 = 0x23,
                /// ADCB Channel 0,1,2,3 combined
                ADCB_CH4 = 0x24,
                /// DACB Channel 0
                DACB_CH0 = 0x25,
                /// DACB Channel 1
                DACB_CH1 = 0x26,
                /// Timer/Counter C0 Overflow
                TCC0_OVF = 0x40,
                /// Timer/Counter C0 Error
                TCC0_ERR = 0x41,
                /// Timer/Counter C0 Compare or Capture A
                TCC0_CCA = 0x42,
                /// Timer/Counter C0 Compare or Capture B
                TCC0_CCB = 0x43,
                /// Timer/Counter C0 Compare or Capture C
                TCC0_CCC = 0x44,
                /// Timer/Counter C0 Compare or Capture D
                TCC0_CCD = 0x45,
                /// Timer/Counter C1 Overflow
                TCC1_OVF = 0x46,
                /// Timer/Counter C1 Error
                TCC1_ERR = 0x47,
                /// Timer/Counter C1 Compare or Capture A
                TCC1_CCA = 0x48,
                /// Timer/Counter C1 Compare or Capture B
                TCC1_CCB = 0x49,
                /// SPI C Transfer Complete
                SPIC = 0x4a,
                /// USART C0 Receive Complete
                USARTC0_RXC = 0x4b,
                /// USART C0 Data Register Empty
                USARTC0_DRE = 0x4c,
                /// USART C1 Receive Complete
                USARTC1_RXC = 0x4e,
                /// USART C1 Data Register Empty
                USARTC1_DRE = 0x4f,
                /// Timer/Counter D0 Overflow
                TCD0_OVF = 0x60,
                /// Timer/Counter D0 Error
                TCD0_ERR = 0x61,
                /// Timer/Counter D0 Compare or Capture A
                TCD0_CCA = 0x62,
                /// Timer/Counter D0 Compare or Capture B
                TCD0_CCB = 0x63,
                /// Timer/Counter D0 Compare or Capture C
                TCD0_CCC = 0x64,
                /// Timer/Counter D0 Compare or Capture D
                TCD0_CCD = 0x65,
                /// Timer/Counter D1 Overflow
                TCD1_OVF = 0x66,
                /// Timer/Counter D1 Error
                TCD1_ERR = 0x67,
                /// Timer/Counter D1 Compare or Capture A
                TCD1_CCA = 0x68,
                /// Timer/Counter D1 Compare or Capture B
                TCD1_CCB = 0x69,
                /// SPI D Transfer Complete
                SPID = 0x6a,
                /// USART D0 Receive Complete
                USARTD0_RXC = 0x6b,
                /// USART D0 Data Register Empty
                USARTD0_DRE = 0x6c,
                /// USART D1 Receive Complete
                USARTD1_RXC = 0x6e,
                /// USART D1 Data Register Empty
                USARTD1_DRE = 0x6f,
                /// Timer/Counter E0 Overflow
                TCE0_OVF = 0x80,
                /// Timer/Counter E0 Error
                TCE0_ERR = 0x81,
                /// Timer/Counter E0 Compare or Capture A
                TCE0_CCA = 0x82,
                /// Timer/Counter E0 Compare or Capture B
                TCE0_CCB = 0x83,
                /// Timer/Counter E0 Compare or Capture C
                TCE0_CCC = 0x84,
                /// Timer/Counter E0 Compare or Capture D
                TCE0_CCD = 0x85,
                /// Timer/Counter E1 Overflow
                TCE1_OVF = 0x86,
                /// Timer/Counter E1 Error
                TCE1_ERR = 0x87,
                /// Timer/Counter E1 Compare or Capture A
                TCE1_CCA = 0x88,
                /// Timer/Counter E1 Compare or Capture B
                TCE1_CCB = 0x89,
                /// SPI E Transfer Complete
                SPIE = 0x8a,
                /// USART E0 Receive Complete
                USARTE0_RXC = 0x8b,
                /// USART E0 Data Register Empty
                USARTE0_DRE = 0x8c,
                /// USART E1 Receive Complete
                USARTE1_RXC = 0x8e,
                /// USART E1 Data Register Empty
                USARTE1_DRE = 0x8f,
                /// Timer/Counter F0 Overflow
                TCF0_OVF = 0xa0,
                /// Timer/Counter F0 Error
                TCF0_ERR = 0xa1,
                /// Timer/Counter F0 Compare or Capture A
                TCF0_CCA = 0xa2,
                /// Timer/Counter F0 Compare or Capture B
                TCF0_CCB = 0xa3,
                /// Timer/Counter F0 Compare or Capture C
                TCF0_CCC = 0xa4,
                /// Timer/Counter F0 Compare or Capture D
                TCF0_CCD = 0xa5,
                /// Timer/Counter F1 Overflow
                TCF1_OVF = 0xa6,
                /// Timer/Counter F1 Error
                TCF1_ERR = 0xa7,
                /// Timer/Counter F1 Compare or Capture A
                TCF1_CCA = 0xa8,
                /// Timer/Counter F1 Compare or Capture B
                TCF1_CCB = 0xa9,
                /// SPI F Transfer Complete
                SPIF = 0xaa,
                /// USART F0 Receive Complete
                USARTF0_RXC = 0xab,
                /// USART F0 Data Register Empty
                USARTF0_DRE = 0xac,
                /// USART F1 Receive Complete
                USARTF1_RXC = 0xae,
                /// USART F1 Data Register Empty
                USARTF1_DRE = 0xaf,
                _,
            };

            /// Interrupt level
            pub const DMA_CH_TRNINTLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Double buffering mode
            pub const DMA_DBUFMODE = enum(u2) {
                /// Double buffering disabled
                DISABLED = 0x0,
                /// Double buffering enabled on channel 0/1
                CH01 = 0x1,
                /// Double buffering enabled on channel 2/3
                CH23 = 0x2,
                /// Double buffering enabled on ch. 0/1 and ch. 2/3
                CH01CH23 = 0x3,
            };

            /// Priority mode
            pub const DMA_PRIMODE = enum(u2) {
                /// Round Robin
                RR0123 = 0x0,
                /// Channel 0 > Round Robin on channel 1/2/3
                CH0RR123 = 0x1,
                /// Channel 0 > channel 1 > Round Robin on channel 2/3
                CH01RR23 = 0x2,
                /// Channel 0 > channel 1 > channel 2 > channel 3
                CH0123 = 0x3,
            };

            /// DMA Controller
            pub const DMA = extern struct {
                /// Control
                CTRL: mmio.Mmio(packed struct(u8) {
                    reserved6: u6,
                    /// Software Reset
                    RESET: u1,
                    /// Enable
                    ENABLE: u1,
                }),
                reserved3: [2]u8,
                /// Transfer Interrupt Status
                INTFLAGS: mmio.Mmio(packed struct(u8) {
                    /// Channel 0 Transaction Complete Interrupt Flag
                    CH0TRNIF: u1,
                    /// Channel 1 Transaction Complete Interrupt Flag
                    CH1TRNIF: u1,
                    /// Channel 2 Transaction Complete Interrupt Flag
                    CH2TRNIF: u1,
                    /// Channel 3 Transaction Complete Interrupt Flag
                    CH3TRNIF: u1,
                    /// Channel 0 Block Transfer Error Interrupt Flag
                    CH0ERRIF: u1,
                    /// Channel 1 Block Transfer Error Interrupt Flag
                    CH1ERRIF: u1,
                    /// Channel 2 Block Transfer Error Interrupt Flag
                    CH2ERRIF: u1,
                    /// Channel 3 Block Transfer Error Interrupt Flag
                    CH3ERRIF: u1,
                }),
                /// Status
                STATUS: mmio.Mmio(packed struct(u8) {
                    /// Channel 0 Block Transfer Pending
                    CH0PEND: u1,
                    /// Channel 1 Block Transfer Pending
                    CH1PEND: u1,
                    /// Channel 2 Block Transfer Pending
                    CH2PEND: u1,
                    /// Channel 3 Block Transfer Pending
                    CH3PEND: u1,
                    /// Channel 0 Block Transfer Busy
                    CH0BUSY: u1,
                    /// Channel 1 Block Transfer Busy
                    CH1BUSY: u1,
                    /// Channel 2 Block Transfer Busy
                    CH2BUSY: u1,
                    /// Channel 3 Block Transfer Busy
                    CH3BUSY: u1,
                }),
                reserved6: [1]u8,
                /// Temporary Register For 16/24-bit Access
                TEMP: u16,
                padding: [72]u8,
            };

            /// DMA Channel
            pub const DMA_CH = extern struct {
                /// Channel Control
                CTRLA: mmio.Mmio(packed struct(u8) {
                    reserved2: u2,
                    /// Channel Single Shot Data Transfer
                    SINGLE: u1,
                    reserved4: u1,
                    /// Channel Transfer Request
                    TRFREQ: u1,
                    /// Channel Repeat Mode
                    REPEAT: u1,
                    /// Channel Software Reset
                    RESET: u1,
                    /// Channel Enable
                    ENABLE: u1,
                }),
                /// Channel Control
                CTRLB: mmio.Mmio(packed struct(u8) {
                    reserved4: u4,
                    /// Transaction Complete Interrupt Flag
                    TRNIF: u1,
                    /// Block Transfer Error Interrupt Flag
                    ERRIF: u1,
                    /// Block Transfer Pending
                    CHPEND: u1,
                    /// Block Transfer Busy
                    CHBUSY: u1,
                }),
                /// Address Control
                ADDRCTRL: u8,
                /// Channel Trigger Source
                TRIGSRC: u8,
                /// Channel Block Transfer Count
                TRFCNT: u16,
                /// Channel Repeat Count
                REPCNT: u8,
                reserved8: [1]u8,
                /// Channel Source Address 0
                SRCADDR0: u8,
                /// Channel Source Address 1
                SRCADDR1: u8,
                /// Channel Source Address 2
                SRCADDR2: u8,
                reserved12: [1]u8,
                /// Channel Destination Address 0
                DESTADDR0: u8,
                /// Channel Destination Address 1
                DESTADDR1: u8,
                /// Channel Destination Address 2
                DESTADDR2: u8,
                padding: [1]u8,
            };
        };

        pub const EVSYS = extern struct {
            /// Event Channel multiplexer input selection
            pub const EVSYS_CHMUX = enum(u8) {
                /// Off
                OFF = 0x0,
                /// RTC Overflow
                RTC_OVF = 0x8,
                /// RTC Compare Match
                RTC_CMP = 0x9,
                /// USB Setup, SOF, CRC error and UNF/OVF
                USB = 0xa,
                /// Analog Comparator A Channel 0
                ACA_CH0 = 0x10,
                /// Analog Comparator A Channel 1
                ACA_CH1 = 0x11,
                /// Analog Comparator A Window
                ACA_WIN = 0x12,
                /// Analog Comparator B Channel 0
                ACB_CH0 = 0x13,
                /// Analog Comparator B Channel 1
                ACB_CH1 = 0x14,
                /// Analog Comparator B Window
                ACB_WIN = 0x15,
                /// ADC A Channel 0
                ADCA_CH0 = 0x20,
                /// ADC A Channel 1
                ADCA_CH1 = 0x21,
                /// ADC A Channel 2
                ADCA_CH2 = 0x22,
                /// ADC A Channel 3
                ADCA_CH3 = 0x23,
                /// ADC B Channel 0
                ADCB_CH0 = 0x24,
                /// ADC B Channel 1
                ADCB_CH1 = 0x25,
                /// ADC B Channel 2
                ADCB_CH2 = 0x26,
                /// ADC B Channel 3
                ADCB_CH3 = 0x27,
                /// Port A, Pin0
                PORTA_PIN0 = 0x50,
                /// Port A, Pin1
                PORTA_PIN1 = 0x51,
                /// Port A, Pin2
                PORTA_PIN2 = 0x52,
                /// Port A, Pin3
                PORTA_PIN3 = 0x53,
                /// Port A, Pin4
                PORTA_PIN4 = 0x54,
                /// Port A, Pin5
                PORTA_PIN5 = 0x55,
                /// Port A, Pin6
                PORTA_PIN6 = 0x56,
                /// Port A, Pin7
                PORTA_PIN7 = 0x57,
                /// Port B, Pin0
                PORTB_PIN0 = 0x58,
                /// Port B, Pin1
                PORTB_PIN1 = 0x59,
                /// Port B, Pin2
                PORTB_PIN2 = 0x5a,
                /// Port B, Pin3
                PORTB_PIN3 = 0x5b,
                /// Port B, Pin4
                PORTB_PIN4 = 0x5c,
                /// Port B, Pin5
                PORTB_PIN5 = 0x5d,
                /// Port B, Pin6
                PORTB_PIN6 = 0x5e,
                /// Port B, Pin7
                PORTB_PIN7 = 0x5f,
                /// Port C, Pin0
                PORTC_PIN0 = 0x60,
                /// Port C, Pin1
                PORTC_PIN1 = 0x61,
                /// Port C, Pin2
                PORTC_PIN2 = 0x62,
                /// Port C, Pin3
                PORTC_PIN3 = 0x63,
                /// Port C, Pin4
                PORTC_PIN4 = 0x64,
                /// Port C, Pin5
                PORTC_PIN5 = 0x65,
                /// Port C, Pin6
                PORTC_PIN6 = 0x66,
                /// Port C, Pin7
                PORTC_PIN7 = 0x67,
                /// Port D, Pin0
                PORTD_PIN0 = 0x68,
                /// Port D, Pin1
                PORTD_PIN1 = 0x69,
                /// Port D, Pin2
                PORTD_PIN2 = 0x6a,
                /// Port D, Pin3
                PORTD_PIN3 = 0x6b,
                /// Port D, Pin4
                PORTD_PIN4 = 0x6c,
                /// Port D, Pin5
                PORTD_PIN5 = 0x6d,
                /// Port D, Pin6
                PORTD_PIN6 = 0x6e,
                /// Port D, Pin7
                PORTD_PIN7 = 0x6f,
                /// Port E, Pin0
                PORTE_PIN0 = 0x70,
                /// Port E, Pin1
                PORTE_PIN1 = 0x71,
                /// Port E, Pin2
                PORTE_PIN2 = 0x72,
                /// Port E, Pin3
                PORTE_PIN3 = 0x73,
                /// Port E, Pin4
                PORTE_PIN4 = 0x74,
                /// Port E, Pin5
                PORTE_PIN5 = 0x75,
                /// Port E, Pin6
                PORTE_PIN6 = 0x76,
                /// Port E, Pin7
                PORTE_PIN7 = 0x77,
                /// Port F, Pin0
                PORTF_PIN0 = 0x78,
                /// Port F, Pin1
                PORTF_PIN1 = 0x79,
                /// Port F, Pin2
                PORTF_PIN2 = 0x7a,
                /// Port F, Pin3
                PORTF_PIN3 = 0x7b,
                /// Port F, Pin4
                PORTF_PIN4 = 0x7c,
                /// Port F, Pin5
                PORTF_PIN5 = 0x7d,
                /// Port F, Pin6
                PORTF_PIN6 = 0x7e,
                /// Port F, Pin7
                PORTF_PIN7 = 0x7f,
                /// Prescaler, divide by 1
                PRESCALER_1 = 0x80,
                /// Prescaler, divide by 2
                PRESCALER_2 = 0x81,
                /// Prescaler, divide by 4
                PRESCALER_4 = 0x82,
                /// Prescaler, divide by 8
                PRESCALER_8 = 0x83,
                /// Prescaler, divide by 16
                PRESCALER_16 = 0x84,
                /// Prescaler, divide by 32
                PRESCALER_32 = 0x85,
                /// Prescaler, divide by 64
                PRESCALER_64 = 0x86,
                /// Prescaler, divide by 128
                PRESCALER_128 = 0x87,
                /// Prescaler, divide by 256
                PRESCALER_256 = 0x88,
                /// Prescaler, divide by 512
                PRESCALER_512 = 0x89,
                /// Prescaler, divide by 1024
                PRESCALER_1024 = 0x8a,
                /// Prescaler, divide by 2048
                PRESCALER_2048 = 0x8b,
                /// Prescaler, divide by 4096
                PRESCALER_4096 = 0x8c,
                /// Prescaler, divide by 8192
                PRESCALER_8192 = 0x8d,
                /// Prescaler, divide by 16384
                PRESCALER_16384 = 0x8e,
                /// Prescaler, divide by 32768
                PRESCALER_32768 = 0x8f,
                /// Timer/Counter C0 Overflow
                TCC0_OVF = 0xc0,
                /// Timer/Counter C0 Error
                TCC0_ERR = 0xc1,
                /// Timer/Counter C0 Compare or Capture A
                TCC0_CCA = 0xc4,
                /// Timer/Counter C0 Compare or Capture B
                TCC0_CCB = 0xc5,
                /// Timer/Counter C0 Compare or Capture C
                TCC0_CCC = 0xc6,
                /// Timer/Counter C0 Compare or Capture D
                TCC0_CCD = 0xc7,
                /// Timer/Counter C1 Overflow
                TCC1_OVF = 0xc8,
                /// Timer/Counter C1 Error
                TCC1_ERR = 0xc9,
                /// Timer/Counter C1 Compare or Capture A
                TCC1_CCA = 0xcc,
                /// Timer/Counter C1 Compare or Capture B
                TCC1_CCB = 0xcd,
                /// Timer/Counter D0 Overflow
                TCD0_OVF = 0xd0,
                /// Timer/Counter D0 Error
                TCD0_ERR = 0xd1,
                /// Timer/Counter D0 Compare or Capture A
                TCD0_CCA = 0xd4,
                /// Timer/Counter D0 Compare or Capture B
                TCD0_CCB = 0xd5,
                /// Timer/Counter D0 Compare or Capture C
                TCD0_CCC = 0xd6,
                /// Timer/Counter D0 Compare or Capture D
                TCD0_CCD = 0xd7,
                /// Timer/Counter D1 Overflow
                TCD1_OVF = 0xd8,
                /// Timer/Counter D1 Error
                TCD1_ERR = 0xd9,
                /// Timer/Counter D1 Compare or Capture A
                TCD1_CCA = 0xdc,
                /// Timer/Counter D1 Compare or Capture B
                TCD1_CCB = 0xdd,
                /// Timer/Counter E0 Overflow
                TCE0_OVF = 0xe0,
                /// Timer/Counter E0 Error
                TCE0_ERR = 0xe1,
                /// Timer/Counter E0 Compare or Capture A
                TCE0_CCA = 0xe4,
                /// Timer/Counter E0 Compare or Capture B
                TCE0_CCB = 0xe5,
                /// Timer/Counter E0 Compare or Capture C
                TCE0_CCC = 0xe6,
                /// Timer/Counter E0 Compare or Capture D
                TCE0_CCD = 0xe7,
                /// Timer/Counter E1 Overflow
                TCE1_OVF = 0xe8,
                /// Timer/Counter E1 Error
                TCE1_ERR = 0xe9,
                /// Timer/Counter E1 Compare or Capture A
                TCE1_CCA = 0xec,
                /// Timer/Counter E1 Compare or Capture B
                TCE1_CCB = 0xed,
                /// Timer/Counter F0 Overflow
                TCF0_OVF = 0xf0,
                /// Timer/Counter F0 Error
                TCF0_ERR = 0xf1,
                /// Timer/Counter F0 Compare or Capture A
                TCF0_CCA = 0xf4,
                /// Timer/Counter F0 Compare or Capture B
                TCF0_CCB = 0xf5,
                /// Timer/Counter F0 Compare or Capture C
                TCF0_CCC = 0xf6,
                /// Timer/Counter F0 Compare or Capture D
                TCF0_CCD = 0xf7,
                /// Timer/Counter F1 Overflow
                TCF1_OVF = 0xf8,
                /// Timer/Counter F1 Error
                TCF1_ERR = 0xf9,
                /// Timer/Counter F1 Compare or Capture A
                TCF1_CCA = 0xfc,
                /// Timer/Counter F1 Compare or Capture B
                TCF1_CCB = 0xfd,
                _,
            };

            /// Digital filter coefficient
            pub const EVSYS_DIGFILT = enum(u3) {
                /// 1 SAMPLE
                @"1SAMPLE" = 0x0,
                /// 2 SAMPLES
                @"2SAMPLES" = 0x1,
                /// 3 SAMPLES
                @"3SAMPLES" = 0x2,
                /// 4 SAMPLES
                @"4SAMPLES" = 0x3,
                /// 5 SAMPLES
                @"5SAMPLES" = 0x4,
                /// 6 SAMPLES
                @"6SAMPLES" = 0x5,
                /// 7 SAMPLES
                @"7SAMPLES" = 0x6,
                /// 8 SAMPLES
                @"8SAMPLES" = 0x7,
            };

            /// Quadrature Decoder Index Recognition Mode
            pub const EVSYS_QDIRM = enum(u2) {
                /// QDPH0 = 0, QDPH90 = 0
                @"00" = 0x0,
                /// QDPH0 = 0, QDPH90 = 1
                @"01" = 0x1,
                /// QDPH0 = 1, QDPH90 = 0
                @"10" = 0x2,
                /// QDPH0 = 1, QDPH90 = 1
                @"11" = 0x3,
            };

            /// Event Channel 0 Multiplexer
            CH0MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 0 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 1 Multiplexer
            CH1MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 1 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 2 Multiplexer
            CH2MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 2 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 3 Multiplexer
            CH3MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 3 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 4 Multiplexer
            CH4MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 4 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 5 Multiplexer
            CH5MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 5 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 6 Multiplexer
            CH6MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 6 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Event Channel 7 Multiplexer
            CH7MUX: mmio.Mmio(packed struct(u8) {
                /// Event Channel 7 Multiplexer
                CHMUX: EVSYS_CHMUX,
            }),
            /// Channel 0 Control Register
            CH0CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                /// Quadrature Decoder Enable
                QDEN: u1,
                /// Quadrature Decoder Index Enable
                QDIEN: u1,
                /// Quadrature Decoder Index Recognition Mode
                QDIRM: EVSYS_QDIRM,
                padding: u1,
            }),
            /// Channel 1 Control Register
            CH1CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                padding: u5,
            }),
            /// Channel 2 Control Register
            CH2CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                /// Quadrature Decoder Enable
                QDEN: u1,
                /// Quadrature Decoder Index Enable
                QDIEN: u1,
                /// Quadrature Decoder Index Recognition Mode
                QDIRM: EVSYS_QDIRM,
                padding: u1,
            }),
            /// Channel 3 Control Register
            CH3CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                padding: u5,
            }),
            /// Channel 4 Control Register
            CH4CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                /// Quadrature Decoder Enable
                QDEN: u1,
                /// Quadrature Decoder Index Enable
                QDIEN: u1,
                /// Quadrature Decoder Index Recognition Mode
                QDIRM: EVSYS_QDIRM,
                padding: u1,
            }),
            /// Channel 5 Control Register
            CH5CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                padding: u5,
            }),
            /// Channel 6 Control Register
            CH6CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                padding: u5,
            }),
            /// Channel 7 Control Register
            CH7CTRL: mmio.Mmio(packed struct(u8) {
                /// Digital Filter
                DIGFILT: EVSYS_DIGFILT,
                padding: u5,
            }),
            /// Event Strobe
            STROBE: u8,
            /// Event Data
            DATA: u8,
        };

        pub const FUSE = struct {
            /// BOD operation
            pub const BODACT = enum(u2) {
                /// BOD enabled in sampled mode
                SAMPLED = 0x1,
                /// BOD enabled continuously
                CONTINUOUS = 0x2,
                /// BOD Disabled
                DISABLED = 0x3,
                _,
            };

            /// Brownout Detection Voltage Level
            pub const BODLVL = enum(u3) {
                /// 3.0 V
                @"3V0" = 0x0,
                /// 2.8 V
                @"2V8" = 0x1,
                /// 2.6 V
                @"2V6" = 0x2,
                /// 2.4 V
                @"2V4" = 0x3,
                /// 2.2 V
                @"2V2" = 0x4,
                /// 2.0 V
                @"2V0" = 0x5,
                /// 1.8 V
                @"1V8" = 0x6,
                /// 1.6 V
                @"1V6" = 0x7,
            };

            /// BOD operation
            pub const BODPD = enum(u2) {
                /// BOD enabled in sampled mode
                SAMPLED = 0x1,
                /// BOD enabled continuously
                CONTINUOUS = 0x2,
                /// BOD Disabled
                DISABLED = 0x3,
                _,
            };

            /// Boot Loader Section Reset Vector
            pub const BOOTRST = enum(u1) {
                /// Boot Loader Reset
                BOOTLDR = 0x0,
                /// Application Reset
                APPLICATION = 0x1,
            };

            /// Start-up Time
            pub const SUT = enum(u2) {
                /// 64 ms
                @"64MS" = 0x0,
                /// 4 ms
                @"4MS" = 0x1,
                /// 0 ms
                @"0MS" = 0x3,
                _,
            };

            /// Timer Oscillator pin location
            pub const TOSCSEL = enum(u1) {
                /// TOSC1 / TOSC2 on separate pins
                ALTERNATE = 0x0,
                /// TOSC1 / TOSC2 shared with XTAL1 / XTAL2
                XTAL = 0x1,
            };

            /// Watchdog (Window) Timeout Period
            pub const WDPER = enum(u4) {
                /// 8 cycles (8ms @ 3.3V)
                @"8CLK" = 0x0,
                /// 16 cycles (16ms @ 3.3V)
                @"16CLK" = 0x1,
                /// 32 cycles (32ms @ 3.3V)
                @"32CLK" = 0x2,
                /// 64 cycles (64ms @ 3.3V)
                @"64CLK" = 0x3,
                /// 128 cycles (0.125s @ 3.3V)
                @"128CLK" = 0x4,
                /// 256 cycles (0.25s @ 3.3V)
                @"256CLK" = 0x5,
                /// 512 cycles (0.5s @ 3.3V)
                @"512CLK" = 0x6,
                /// 1K cycles (1s @ 3.3V)
                @"1KCLK" = 0x7,
                /// 2K cycles (2s @ 3.3V)
                @"2KCLK" = 0x8,
                /// 4K cycles (4s @ 3.3V)
                @"4KCLK" = 0x9,
                /// 8K cycles (8s @ 3.3V)
                @"8KCLK" = 0xa,
                _,
            };

            /// Watchdog (Window) Timeout Period
            pub const WDWPER = enum(u4) {
                /// 8 cycles (8ms @ 3.3V)
                @"8CLK" = 0x0,
                /// 16 cycles (16ms @ 3.3V)
                @"16CLK" = 0x1,
                /// 32 cycles (32ms @ 3.3V)
                @"32CLK" = 0x2,
                /// 64 cycles (64ms @ 3.3V)
                @"64CLK" = 0x3,
                /// 128 cycles (0.125s @ 3.3V)
                @"128CLK" = 0x4,
                /// 256 cycles (0.25s @ 3.3V)
                @"256CLK" = 0x5,
                /// 512 cycles (0.5s @ 3.3V)
                @"512CLK" = 0x6,
                /// 1K cycles (1s @ 3.3V)
                @"1KCLK" = 0x7,
                /// 2K cycles (2s @ 3.3V)
                @"2KCLK" = 0x8,
                /// 4K cycles (4s @ 3.3V)
                @"4KCLK" = 0x9,
                /// 8K cycles (8s @ 3.3V)
                @"8KCLK" = 0xa,
                _,
            };

            /// Fuses
            pub const NVM_FUSES = extern struct {
                /// JTAG User ID
                FUSEBYTE0: mmio.Mmio(packed struct(u8) {
                    /// JTAG User ID
                    JTAGUID: u8,
                }),
                /// Watchdog Configuration
                FUSEBYTE1: u8,
                /// Reset Configuration
                FUSEBYTE2: u8,
                reserved4: [1]u8,
                /// Start-up Configuration
                FUSEBYTE4: mmio.Mmio(packed struct(u8) {
                    /// JTAG Interface Enable
                    JTAGEN: u1,
                    /// Watchdog Timer Lock
                    WDLOCK: u1,
                    reserved4: u2,
                    /// External Reset Disable
                    RSTDISBL: u1,
                    padding: u3,
                }),
                /// EESAVE and BOD Level
                FUSEBYTE5: mmio.Mmio(packed struct(u8) {
                    reserved3: u3,
                    /// Preserve EEPROM Through Chip Erase
                    EESAVE: u1,
                    padding: u4,
                }),
            };
        };

        pub const GPIO = extern struct {
            /// General Purpose IO Register 0
            GPIOR0: u8,
            /// General Purpose IO Register 1
            GPIOR1: u8,
            /// General Purpose IO Register 2
            GPIOR2: u8,
            /// General Purpose IO Register 3
            GPIOR3: u8,
            /// General Purpose IO Register 4
            GPIOR4: u8,
            /// General Purpose IO Register 5
            GPIOR5: u8,
            /// General Purpose IO Register 6
            GPIOR6: u8,
            /// General Purpose IO Register 7
            GPIOR7: u8,
            /// General Purpose IO Register 8
            GPIOR8: u8,
            /// General Purpose IO Register 9
            GPIOR9: u8,
            /// General Purpose IO Register 10
            GPIORA: u8,
            /// General Purpose IO Register 11
            GPIORB: u8,
            /// General Purpose IO Register 12
            GPIORC: u8,
            /// General Purpose IO Register 13
            GPIORD: u8,
            /// General Purpose IO Register 14
            GPIORE: u8,
            /// General Purpose IO Register 15
            GPIORF: u8,
        };

        pub const HIRES = extern struct {
            /// High Resolution Enable
            pub const HIRES_HREN = enum(u2) {
                /// No Fault Protection
                NONE = 0x0,
                /// Enable High Resolution on Timer/Counter 0
                TC0 = 0x1,
                /// Enable High Resolution on Timer/Counter 1
                TC1 = 0x2,
                /// Enable High Resolution both Timer/Counters
                BOTH = 0x3,
            };

            /// Control Register
            CTRLA: mmio.Mmio(packed struct(u8) {
                /// High Resolution Enable
                HREN: HIRES_HREN,
                /// High Resolution Plus
                HRPLUS: u1,
                padding: u5,
            }),
        };

        pub const IRCOM = extern struct {
            /// Event channel selection
            pub const IRDA_EVSEL = enum(u4) {
                /// No Event Source
                OFF = 0x0,
                /// Event Channel 0
                @"0" = 0x8,
                /// Event Channel 1
                @"1" = 0x9,
                /// Event Channel 2
                @"2" = 0xa,
                /// Event Channel 3
                @"3" = 0xb,
                /// Event Channel 4
                @"4" = 0xc,
                /// Event Channel 5
                @"5" = 0xd,
                /// Event Channel 6
                @"6" = 0xe,
                /// Event Channel 7
                @"7" = 0xf,
                _,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Event Channel Select
                EVSEL: IRDA_EVSEL,
                padding: u4,
            }),
            /// IrDA Transmitter Pulse Length Control Register
            TXPLCTRL: u8,
            /// IrDA Receiver Pulse Length Control Register
            RXPLCTRL: u8,
        };

        pub const LOCKBIT = struct {
            /// Boot lock bits - application section
            pub const FUSE_BLBA = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Read not allowed
                RLOCK = 0x1,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
            };

            /// Boot lock bits - application table section
            pub const FUSE_BLBAT = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Read not allowed
                RLOCK = 0x1,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
            };

            /// Boot lock bits - boot section
            pub const FUSE_BLBB = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Read not allowed
                RLOCK = 0x1,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
            };

            /// Lock bits
            pub const FUSE_LB = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
                _,
            };

            /// Lock Bits
            pub const NVM_LOCKBITS = extern struct {
                /// Lock Bits
                LOCKBITS: u8,
            };
        };

        pub const MCU = extern struct {
            /// Device ID byte 0
            DEVID0: u8,
            /// Device ID byte 1
            DEVID1: u8,
            /// Device ID byte 2
            DEVID2: u8,
            /// Revision ID
            REVID: u8,
            /// JTAG User ID
            JTAGUID: u8,
            reserved6: [1]u8,
            /// MCU Control
            MCUCR: mmio.Mmio(packed struct(u8) {
                /// JTAG Disable
                JTAGD: u1,
                padding: u7,
            }),
            /// Analog Startup Delay
            ANAINIT: mmio.Mmio(packed struct(u8) {
                /// Analog startup delay Port A
                STARTUPDLYA: u2,
                /// Analog startup delay Port B
                STARTUPDLYB: u2,
                padding: u4,
            }),
            /// Event System Lock
            EVSYSLOCK: mmio.Mmio(packed struct(u8) {
                /// Event Channel 0-3 Lock
                EVSYS0LOCK: u1,
                reserved4: u3,
                /// Event Channel 4-7 Lock
                EVSYS1LOCK: u1,
                padding: u3,
            }),
            /// AWEX Lock
            AWEXLOCK: mmio.Mmio(packed struct(u8) {
                /// AWeX on T/C C0 Lock
                AWEXCLOCK: u1,
                /// AWeX on T/C D0 Lock
                AWEXDLOCK: u1,
                /// AWeX on T/C E0 Lock
                AWEXELOCK: u1,
                /// AWeX on T/C F0 Lock
                AWEXFLOCK: u1,
                padding: u4,
            }),
        };

        pub const NVM = extern struct {
            /// Boot lock bits - application section
            pub const NVM_BLBA = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Read not allowed
                RLOCK = 0x1,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
            };

            /// Boot lock bits - application table section
            pub const NVM_BLBAT = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Read not allowed
                RLOCK = 0x1,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
            };

            /// Boot lock bits - boot section
            pub const NVM_BLBB = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Read not allowed
                RLOCK = 0x1,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
            };

            /// NVM Command
            pub const NVM_CMD = enum(u7) {
                /// Noop/Ordinary LPM
                NO_OPERATION = 0x0,
                /// Read user signature row
                READ_USER_SIG_ROW = 0x1,
                /// Read calibration row
                READ_CALIB_ROW = 0x2,
                /// Read EEPROM
                READ_EEPROM = 0x6,
                /// Read fuse byte
                READ_FUSES = 0x7,
                /// Write lock bits
                WRITE_LOCK_BITS = 0x8,
                /// Erase user signature row
                ERASE_USER_SIG_ROW = 0x18,
                /// Write user signature row
                WRITE_USER_SIG_ROW = 0x1a,
                /// Erase Application Section
                ERASE_APP = 0x20,
                /// Erase Application Section page
                ERASE_APP_PAGE = 0x22,
                /// Load Flash page buffer
                LOAD_FLASH_BUFFER = 0x23,
                /// Write Application Section page
                WRITE_APP_PAGE = 0x24,
                /// Erase-and-write Application Section page
                ERASE_WRITE_APP_PAGE = 0x25,
                /// Erase/flush Flash page buffer
                ERASE_FLASH_BUFFER = 0x26,
                /// Erase Boot Section page
                ERASE_BOOT_PAGE = 0x2a,
                /// Erase Flash Page
                ERASE_FLASH_PAGE = 0x2b,
                /// Write Boot Section page
                WRITE_BOOT_PAGE = 0x2c,
                /// Erase-and-write Boot Section page
                ERASE_WRITE_BOOT_PAGE = 0x2d,
                /// Write Flash Page
                WRITE_FLASH_PAGE = 0x2e,
                /// Erase-and-write Flash Page
                ERASE_WRITE_FLASH_PAGE = 0x2f,
                /// Erase EEPROM
                ERASE_EEPROM = 0x30,
                /// Erase EEPROM page
                ERASE_EEPROM_PAGE = 0x32,
                /// Load EEPROM page buffer
                LOAD_EEPROM_BUFFER = 0x33,
                /// Write EEPROM page
                WRITE_EEPROM_PAGE = 0x34,
                /// Erase-and-write EEPROM page
                ERASE_WRITE_EEPROM_PAGE = 0x35,
                /// Erase/flush EEPROM page buffer
                ERASE_EEPROM_BUFFER = 0x36,
                /// Application section CRC
                APP_CRC = 0x38,
                /// Boot Section CRC
                BOOT_CRC = 0x39,
                /// Flash Range CRC
                FLASH_RANGE_CRC = 0x3a,
                /// Erase Chip
                CHIP_ERASE = 0x40,
                /// Read NVM
                READ_NVM = 0x43,
                /// Write Fuse byte
                WRITE_FUSE = 0x4c,
                /// Erase Boot Section
                ERASE_BOOT = 0x68,
                /// Flash CRC
                FLASH_CRC = 0x78,
                _,
            };

            /// EEPROM ready interrupt level
            pub const NVM_EELVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Lock bits
            pub const NVM_LB = enum(u2) {
                /// Read and write not allowed
                RWLOCK = 0x0,
                /// Write not allowed
                WLOCK = 0x2,
                /// No locks
                NOLOCK = 0x3,
                _,
            };

            /// SPM ready interrupt level
            pub const NVM_SPMLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Address Register 0
            ADDR0: u8,
            /// Address Register 1
            ADDR1: u8,
            /// Address Register 2
            ADDR2: u8,
            reserved4: [1]u8,
            /// Data Register 0
            DATA0: u8,
            /// Data Register 1
            DATA1: u8,
            /// Data Register 2
            DATA2: u8,
            reserved10: [3]u8,
            /// Command
            CMD: mmio.Mmio(packed struct(u8) {
                /// Command
                CMD: NVM_CMD,
                padding: u1,
            }),
            /// Control Register A
            CTRLA: mmio.Mmio(packed struct(u8) {
                /// Command Execute
                CMDEX: u1,
                padding: u7,
            }),
            /// Control Register B
            CTRLB: mmio.Mmio(packed struct(u8) {
                /// SPM Lock
                SPMLOCK: u1,
                /// EEPROM Power Reduction Enable
                EPRM: u1,
                /// Flash Power Reduction Enable
                FPRM: u1,
                /// EEPROM Mapping Enable
                EEMAPEN: u1,
                padding: u4,
            }),
            /// Interrupt Control
            INTCTRL: mmio.Mmio(packed struct(u8) {
                /// EEPROM Interrupt Level
                EELVL: NVM_EELVL,
                /// SPM Interrupt Level
                SPMLVL: NVM_SPMLVL,
                padding: u4,
            }),
            reserved15: [1]u8,
            /// Status
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Flash Page Buffer Active Loading
                FLOAD: u1,
                /// EEPROM Page Buffer Active Loading
                EELOAD: u1,
                reserved6: u4,
                /// Flash Memory Busy
                FBUSY: u1,
                /// Non-volatile Memory Busy
                NVMBUSY: u1,
            }),
            /// Lock Bits
            LOCKBITS: mmio.Mmio(packed struct(u8) {
                /// Lock Bits
                LB: NVM_LB,
                /// Boot Lock Bits - Application Table
                BLBAT: NVM_BLBAT,
                /// Boot Lock Bits - Application Section
                BLBA: NVM_BLBA,
                /// Boot Lock Bits - Boot Section
                BLBB: NVM_BLBB,
            }),
        };

        pub const OSC = extern struct {
            /// Oscillator Frequency Range
            pub const OSC_FRQRANGE = enum(u2) {
                /// 0.4 - 2 MHz
                @"04TO2" = 0x0,
                /// 2 - 9 MHz
                @"2TO9" = 0x1,
                /// 9 - 12 MHz
                @"9TO12" = 0x2,
                /// 12 - 16 MHz
                @"12TO16" = 0x3,
            };

            /// PLL Clock Source
            pub const OSC_PLLSRC = enum(u2) {
                /// Internal 2 MHz RC Oscillator
                RC2M = 0x0,
                /// Internal 32 MHz RC Oscillator
                RC32M = 0x2,
                /// External Oscillator
                XOSC = 0x3,
                _,
            };

            /// 2 MHz DFLL Calibration Reference
            pub const OSC_RC2MCREF = enum(u1) {
                /// Internal 32.768 kHz RC Oscillator
                RC32K = 0x0,
                /// External 32.768 kHz Crystal Oscillator
                XOSC32K = 0x1,
            };

            /// 32 MHz DFLL Calibration Reference
            pub const OSC_RC32MCREF = enum(u2) {
                /// Internal 32.768 kHz RC Oscillator
                RC32K = 0x0,
                /// External 32.768 kHz Crystal Oscillator
                XOSC32K = 0x1,
                /// USB Start of Frame
                USBSOF = 0x2,
                _,
            };

            /// External Oscillator Selection and Startup Time
            pub const OSC_XOSCSEL = enum(u4) {
                /// External Clock - 6 CLK
                EXTCLK = 0x0,
                /// 32.768 kHz TOSC - 32K CLK
                @"32KHz" = 0x2,
                /// 0.4-16 MHz XTAL - 256 CLK
                XTAL_256CLK = 0x3,
                /// 0.4-16 MHz XTAL - 1K CLK
                XTAL_1KCLK = 0x7,
                /// 0.4-16 MHz XTAL - 16K CLK
                XTAL_16KCLK = 0xb,
                _,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Internal 2 MHz RC Oscillator Enable
                RC2MEN: u1,
                /// Internal 32 MHz RC Oscillator Enable
                RC32MEN: u1,
                /// Internal 32.768 kHz RC Oscillator Enable
                RC32KEN: u1,
                /// External Oscillator Enable
                XOSCEN: u1,
                /// PLL Enable
                PLLEN: u1,
                padding: u3,
            }),
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Internal 2 MHz RC Oscillator Ready
                RC2MRDY: u1,
                /// Internal 32 MHz RC Oscillator Ready
                RC32MRDY: u1,
                /// Internal 32.768 kHz RC Oscillator Ready
                RC32KRDY: u1,
                /// External Oscillator Ready
                XOSCRDY: u1,
                /// PLL Ready
                PLLRDY: u1,
                padding: u3,
            }),
            /// External Oscillator Control Register
            XOSCCTRL: mmio.Mmio(packed struct(u8) {
                /// External Oscillator Selection and Startup Time
                XOSCSEL: OSC_XOSCSEL,
                /// 16 MHz Crystal Oscillator High Power mode
                XOSCPWR: u1,
                /// 32.768 kHz XTAL OSC Low-power Mode
                X32KLPM: u1,
                /// Frequency Range
                FRQRANGE: OSC_FRQRANGE,
            }),
            /// Oscillator Failure Detection Register
            XOSCFAIL: mmio.Mmio(packed struct(u8) {
                /// XOSC Failure Detection Enable
                XOSCFDEN: u1,
                /// XOSC Failure Detection Interrupt Flag
                XOSCFDIF: u1,
                /// PLL Failure Detection Enable
                PLLFDEN: u1,
                /// PLL Failure Detection Interrupt Flag
                PLLFDIF: u1,
                padding: u4,
            }),
            /// 32.768 kHz Internal Oscillator Calibration Register
            RC32KCAL: u8,
            /// PLL Control Register
            PLLCTRL: mmio.Mmio(packed struct(u8) {
                /// Multiplication Factor
                PLLFAC: u5,
                /// Divide by 2
                PLLDIV: u1,
                /// Clock Source
                PLLSRC: OSC_PLLSRC,
            }),
            /// DFLL Control Register
            DFLLCTRL: mmio.Mmio(packed struct(u8) {
                /// 2 MHz DFLL Calibration Reference
                RC2MCREF: OSC_RC2MCREF,
                /// 32 MHz DFLL Calibration Reference
                RC32MCREF: OSC_RC32MCREF,
                padding: u5,
            }),
        };

        pub const PMIC = extern struct {
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Low Level Interrupt Executing
                LOLVLEX: u1,
                /// Medium Level Interrupt Executing
                MEDLVLEX: u1,
                /// High Level Interrupt Executing
                HILVLEX: u1,
                reserved7: u4,
                /// Non-maskable Interrupt Executing
                NMIEX: u1,
            }),
            /// Interrupt Priority
            INTPRI: mmio.Mmio(packed struct(u8) {
                /// Interrupt Priority
                INTPRI: u8,
            }),
            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Low Level Enable
                LOLVLEN: u1,
                /// Medium Level Enable
                MEDLVLEN: u1,
                /// High Level Enable
                HILVLEN: u1,
                reserved6: u3,
                /// Interrupt Vector Select
                IVSEL: u1,
                /// Round-Robin Priority Enable
                RREN: u1,
            }),
        };

        pub const PORT = extern struct {
            /// Port Interrupt 0 Level
            pub const PORT_INT0LVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Port Interrupt 1 Level
            pub const PORT_INT1LVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Input/Sense Configuration
            pub const PORT_ISC = enum(u3) {
                /// Sense Both Edges
                BOTHEDGES = 0x0,
                /// Sense Rising Edge
                RISING = 0x1,
                /// Sense Falling Edge
                FALLING = 0x2,
                /// Sense Level (Transparent For Events)
                LEVEL = 0x3,
                /// Disable Digital Input Buffer
                INPUT_DISABLE = 0x7,
                _,
            };

            /// Output/Pull Configuration
            pub const PORT_OPC = enum(u3) {
                /// Totempole
                TOTEM = 0x0,
                /// Totempole w/ Bus keeper on Input and Output
                BUSKEEPER = 0x1,
                /// Totempole w/ Pull-down on Input
                PULLDOWN = 0x2,
                /// Totempole w/ Pull-up on Input
                PULLUP = 0x3,
                /// Wired OR
                WIREDOR = 0x4,
                /// Wired AND
                WIREDAND = 0x5,
                /// Wired OR w/ Pull-down
                WIREDORPULL = 0x6,
                /// Wired AND w/ Pull-up
                WIREDANDPULL = 0x7,
            };

            /// I/O Port Data Direction
            DIR: u8,
            /// I/O Port Data Direction Set
            DIRSET: u8,
            /// I/O Port Data Direction Clear
            DIRCLR: u8,
            /// I/O Port Data Direction Toggle
            DIRTGL: u8,
            /// I/O Port Output
            OUT: u8,
            /// I/O Port Output Set
            OUTSET: u8,
            /// I/O Port Output Clear
            OUTCLR: u8,
            /// I/O Port Output Toggle
            OUTTGL: u8,
            /// I/O port Input
            IN: u8,
            /// Interrupt Control Register
            INTCTRL: mmio.Mmio(packed struct(u8) {
                /// Port Interrupt 0 Level
                INT0LVL: PORT_INT0LVL,
                /// Port Interrupt 1 Level
                INT1LVL: PORT_INT1LVL,
                padding: u4,
            }),
            /// Port Interrupt 0 Mask
            INT0MASK: u8,
            /// Port Interrupt 1 Mask
            INT1MASK: u8,
            /// Interrupt Flag Register
            INTFLAGS: mmio.Mmio(packed struct(u8) {
                /// Port Interrupt 0 Flag
                INT0IF: u1,
                /// Port Interrupt 1 Flag
                INT1IF: u1,
                padding: u6,
            }),
            reserved14: [1]u8,
            /// I/O Port Pin Remap Register
            REMAP: mmio.Mmio(packed struct(u8) {
                /// Timer/Counter 0 Output Compare A
                TC0A: u1,
                /// Timer/Counter 0 Output Compare B
                TC0B: u1,
                /// Timer/Counter 0 Output Compare C
                TC0C: u1,
                /// Timer/Counter 0 Output Compare D
                TC0D: u1,
                /// USART0
                USART0: u1,
                /// SPI
                SPI: u1,
                padding: u2,
            }),
            reserved16: [1]u8,
            /// Pin 0 Control Register
            PIN0CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 1 Control Register
            PIN1CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 2 Control Register
            PIN2CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 3 Control Register
            PIN3CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 4 Control Register
            PIN4CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 5 Control Register
            PIN5CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 6 Control Register
            PIN6CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
            /// Pin 7 Control Register
            PIN7CTRL: mmio.Mmio(packed struct(u8) {
                /// Input/Sense Configuration
                ISC: PORT_ISC,
                /// Output/Pull Configuration
                OPC: PORT_OPC,
                /// Inverted I/O Enable
                INVEN: u1,
                /// Slew Rate Enable
                SRLEN: u1,
            }),
        };

        pub const PORTCFG = extern struct {
            /// Clock and Event Output Port
            pub const PORTCFG_CLKEVPIN = enum(u1) {
                /// Clock and Event Output on PIN 7
                PIN7 = 0x0,
                /// Clock and Event Output on PIN 4
                PIN4 = 0x1,
            };

            /// System Clock Output Port
            pub const PORTCFG_CLKOUT = enum(u2) {
                /// System Clock Output Disabled
                OFF = 0x0,
                /// System Clock Output on Port C pin 7
                PC7 = 0x1,
                /// System Clock Output on Port D pin 7
                PD7 = 0x2,
                /// System Clock Output on Port E pin 7
                PE7 = 0x3,
            };

            /// Peripheral Clock Output Select
            pub const PORTCFG_CLKOUTSEL = enum(u2) {
                /// 1x Peripheral Clock Output to pin
                CLK1X = 0x0,
                /// 2x Peripheral Clock Output to pin
                CLK2X = 0x1,
                /// 4x Peripheral Clock Output to pin
                CLK4X = 0x2,
                _,
            };

            /// Event Output Port
            pub const PORTCFG_EVOUT = enum(u2) {
                /// Event Output Disabled
                OFF = 0x0,
                /// Event Channel 7 Output on Port C pin 7
                PC7 = 0x1,
                /// Event Channel 7 Output on Port D pin 7
                PD7 = 0x2,
                /// Event Channel 7 Output on Port E pin 7
                PE7 = 0x3,
            };

            /// Event Output Select
            pub const PORTCFG_EVOUTSEL = enum(u3) {
                /// Event Channel 0 output to pin
                @"0" = 0x0,
                /// Event Channel 1 output to pin
                @"1" = 0x1,
                /// Event Channel 2 output to pin
                @"2" = 0x2,
                /// Event Channel 3 output to pin
                @"3" = 0x3,
                /// Event Channel 4 output to pin
                @"4" = 0x4,
                /// Event Channel 5 output to pin
                @"5" = 0x5,
                /// Event Channel 6 output to pin
                @"6" = 0x6,
                /// Event Channel 7 output to pin
                @"7" = 0x7,
            };

            /// Virtual Port Mapping
            pub const PORTCFG_VP02MAP = enum(u4) {
                /// Mapped To PORTA
                PORTA = 0x0,
                /// Mapped To PORTB
                PORTB = 0x1,
                /// Mapped To PORTC
                PORTC = 0x2,
                /// Mapped To PORTD
                PORTD = 0x3,
                /// Mapped To PORTE
                PORTE = 0x4,
                /// Mapped To PORTF
                PORTF = 0x5,
                /// Mapped To PORTG
                PORTG = 0x6,
                /// Mapped To PORTH
                PORTH = 0x7,
                /// Mapped To PORTJ
                PORTJ = 0x8,
                /// Mapped To PORTK
                PORTK = 0x9,
                /// Mapped To PORTL
                PORTL = 0xa,
                /// Mapped To PORTM
                PORTM = 0xb,
                /// Mapped To PORTN
                PORTN = 0xc,
                /// Mapped To PORTP
                PORTP = 0xd,
                /// Mapped To PORTQ
                PORTQ = 0xe,
                /// Mapped To PORTR
                PORTR = 0xf,
            };

            /// Virtual Port Mapping
            pub const PORTCFG_VP13MAP = enum(u4) {
                /// Mapped To PORTA
                PORTA = 0x0,
                /// Mapped To PORTB
                PORTB = 0x1,
                /// Mapped To PORTC
                PORTC = 0x2,
                /// Mapped To PORTD
                PORTD = 0x3,
                /// Mapped To PORTE
                PORTE = 0x4,
                /// Mapped To PORTF
                PORTF = 0x5,
                /// Mapped To PORTG
                PORTG = 0x6,
                /// Mapped To PORTH
                PORTH = 0x7,
                /// Mapped To PORTJ
                PORTJ = 0x8,
                /// Mapped To PORTK
                PORTK = 0x9,
                /// Mapped To PORTL
                PORTL = 0xa,
                /// Mapped To PORTM
                PORTM = 0xb,
                /// Mapped To PORTN
                PORTN = 0xc,
                /// Mapped To PORTP
                PORTP = 0xd,
                /// Mapped To PORTQ
                PORTQ = 0xe,
                /// Mapped To PORTR
                PORTR = 0xf,
            };

            /// Multi-pin Configuration Mask
            MPCMASK: u8,
            reserved2: [1]u8,
            /// Virtual Port Control Register A
            VPCTRLA: mmio.Mmio(packed struct(u8) {
                /// Virtual Port 0 Mapping
                VP0MAP: PORTCFG_VP02MAP,
                /// Virtual Port 1 Mapping
                VP1MAP: PORTCFG_VP13MAP,
            }),
            /// Virtual Port Control Register B
            VPCTRLB: mmio.Mmio(packed struct(u8) {
                /// Virtual Port 2 Mapping
                VP2MAP: PORTCFG_VP02MAP,
                /// Virtual Port 3 Mapping
                VP3MAP: PORTCFG_VP13MAP,
            }),
            /// Clock and Event Out Register
            CLKEVOUT: mmio.Mmio(packed struct(u8) {
                /// Peripheral Clock Output Port
                CLKOUT: PORTCFG_CLKOUT,
                /// Peripheral Clock Output Select
                CLKOUTSEL: PORTCFG_CLKOUTSEL,
                /// Event Output Port
                EVOUT: PORTCFG_EVOUT,
                /// RTC Clock Output
                RTCOUT: u1,
                /// Peripheral Clock and Event Output pin Select
                CLKEVPIN: PORTCFG_CLKEVPIN,
            }),
            reserved6: [1]u8,
            /// Event Output Select
            EVOUTSEL: mmio.Mmio(packed struct(u8) {
                /// Event Output Select
                EVOUTSEL: PORTCFG_EVOUTSEL,
                padding: u5,
            }),
        };

        pub const PR = extern struct {
            /// General Power Reduction
            PRGEN: mmio.Mmio(packed struct(u8) {
                /// DMA-Controller
                DMA: u1,
                /// Event System
                EVSYS: u1,
                /// Real-time Counter
                RTC: u1,
                reserved4: u1,
                /// AES
                AES: u1,
                reserved6: u1,
                /// USB
                USB: u1,
                padding: u1,
            }),
            /// Power Reduction Port A
            PRPA: mmio.Mmio(packed struct(u8) {
                /// Port A Analog Comparator
                AC: u1,
                /// Port A ADC
                ADC: u1,
                /// Port A DAC
                DAC: u1,
                padding: u5,
            }),
            /// Power Reduction Port B
            PRPB: mmio.Mmio(packed struct(u8) {
                /// Port B Analog Comparator
                AC: u1,
                /// Port B ADC
                ADC: u1,
                /// Port B DAC
                DAC: u1,
                padding: u5,
            }),
            /// Power Reduction Port C
            PRPC: mmio.Mmio(packed struct(u8) {
                /// Port C Timer/Counter0
                TC0: u1,
                /// Port C Timer/Counter1
                TC1: u1,
                /// Port C AWEX
                HIRES: u1,
                /// Port C SPI
                SPI: u1,
                /// Port C USART0
                USART0: u1,
                /// Port C USART1
                USART1: u1,
                /// Port C Two-wire Interface
                TWI: u1,
                padding: u1,
            }),
            /// Power Reduction Port D
            PRPD: mmio.Mmio(packed struct(u8) {
                /// Port D Timer/Counter0
                TC0: u1,
                /// Port D Timer/Counter1
                TC1: u1,
                /// Port D AWEX
                HIRES: u1,
                /// Port D SPI
                SPI: u1,
                /// Port D USART0
                USART0: u1,
                /// Port D USART1
                USART1: u1,
                /// Port D Two-wire Interface
                TWI: u1,
                padding: u1,
            }),
            /// Power Reduction Port E
            PRPE: mmio.Mmio(packed struct(u8) {
                /// Port E Timer/Counter0
                TC0: u1,
                /// Port E Timer/Counter1
                TC1: u1,
                /// Port E AWEX
                HIRES: u1,
                /// Port E SPI
                SPI: u1,
                /// Port E USART0
                USART0: u1,
                /// Port E USART1
                USART1: u1,
                /// Port E Two-wire Interface
                TWI: u1,
                padding: u1,
            }),
            /// Power Reduction Port F
            PRPF: mmio.Mmio(packed struct(u8) {
                /// Port F Timer/Counter0
                TC0: u1,
                /// Port F Timer/Counter1
                TC1: u1,
                /// Port F AWEX
                HIRES: u1,
                /// Port F SPI
                SPI: u1,
                /// Port F USART0
                USART0: u1,
                /// Port F USART1
                USART1: u1,
                /// Port F Two-wire Interface
                TWI: u1,
                padding: u1,
            }),
        };

        pub const RST = extern struct {
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Power-on Reset Flag
                PORF: u1,
                /// External Reset Flag
                EXTRF: u1,
                /// Brown-out Reset Flag
                BORF: u1,
                /// Watchdog Reset Flag
                WDRF: u1,
                /// Programming and Debug Interface Interface Reset Flag
                PDIRF: u1,
                /// Software Reset Flag
                SRF: u1,
                /// Spike Detection Reset Flag
                SDRF: u1,
                padding: u1,
            }),
            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Software Reset
                SWRST: u1,
                padding: u7,
            }),
        };

        pub const RTC32 = extern struct {
            /// Compare Interrupt level
            pub const RTC32_COMPINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Overflow Interrupt level
            pub const RTC32_OVFINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// RTC enable
                ENABLE: u1,
                padding: u7,
            }),
            /// Synchronization Control/Status Register
            SYNCCTRL: mmio.Mmio(packed struct(u8) {
                /// Synchronization Busy Flag
                SYNCBUSY: u1,
                reserved4: u3,
                /// Synchronization Busy Flag
                SYNCCNT: u1,
                padding: u3,
            }),
            /// Interrupt Control Register
            INTCTRL: mmio.Mmio(packed struct(u8) {
                /// Overflow Interrupt Level
                OVFINTLVL: RTC32_OVFINTLVL,
                /// Compare Match Interrupt Level
                COMPINTLVL: RTC32_COMPINTLVL,
                padding: u4,
            }),
            /// Interrupt Flags
            INTFLAGS: mmio.Mmio(packed struct(u8) {
                /// Overflow Interrupt Flag
                OVFIF: u1,
                /// Compare Match Interrupt Flag
                COMPIF: u1,
                padding: u6,
            }),
            /// Count Register
            CNT: u32,
            /// Period Register
            PER: u32,
            /// Compare Register
            COMP: u32,
        };

        pub const SIGROW = struct {
            /// Production Signatures
            pub const NVM_PROD_SIGNATURES = extern struct {
                /// RCOSC 2 MHz Calibration Value B
                RCOSC2M: u8,
                /// RCOSC 2 MHz Calibration Value A
                RCOSC2MA: u8,
                /// RCOSC 32.768 kHz Calibration Value
                RCOSC32K: u8,
                /// RCOSC 32 MHz Calibration Value B
                RCOSC32M: u8,
                /// RCOSC 32 MHz Calibration Value A
                RCOSC32MA: u8,
                reserved8: [3]u8,
                /// Lot Number Byte 0, ASCII
                LOTNUM0: u8,
                /// Lot Number Byte 1, ASCII
                LOTNUM1: u8,
                /// Lot Number Byte 2, ASCII
                LOTNUM2: u8,
                /// Lot Number Byte 3, ASCII
                LOTNUM3: u8,
                /// Lot Number Byte 4, ASCII
                LOTNUM4: u8,
                /// Lot Number Byte 5, ASCII
                LOTNUM5: u8,
                reserved16: [2]u8,
                /// Wafer Number
                WAFNUM: u8,
                reserved18: [1]u8,
                /// Wafer Coordinate X Byte 0
                COORDX0: u8,
                /// Wafer Coordinate X Byte 1
                COORDX1: u8,
                /// Wafer Coordinate Y Byte 0
                COORDY0: u8,
                /// Wafer Coordinate Y Byte 1
                COORDY1: u8,
                reserved26: [4]u8,
                /// USB Calibration Byte 0
                USBCAL0: u8,
                /// USB Calibration Byte 1
                USBCAL1: u8,
                /// USB RCOSC Calibration Value B
                USBRCOSC: u8,
                /// USB RCOSC Calibration Value A
                USBRCOSCA: u8,
                reserved32: [2]u8,
                /// ADCA Calibration Byte 0
                ADCACAL0: u8,
                /// ADCA Calibration Byte 1
                ADCACAL1: u8,
                reserved36: [2]u8,
                /// ADCB Calibration Byte 0
                ADCBCAL0: u8,
                /// ADCB Calibration Byte 1
                ADCBCAL1: u8,
                reserved46: [8]u8,
                /// Temperature Sensor Calibration Byte 0
                TEMPSENSE0: u8,
                /// Temperature Sensor Calibration Byte 1
                TEMPSENSE1: u8,
                /// DACA0 Calibration Byte 0
                DACA0OFFCAL: u8,
                /// DACA0 Calibration Byte 1
                DACA0GAINCAL: u8,
                /// DACB0 Calibration Byte 0
                DACB0OFFCAL: u8,
                /// DACB0 Calibration Byte 1
                DACB0GAINCAL: u8,
                /// DACA1 Calibration Byte 0
                DACA1OFFCAL: u8,
                /// DACA1 Calibration Byte 1
                DACA1GAINCAL: u8,
                /// DACB1 Calibration Byte 0
                DACB1OFFCAL: u8,
                /// DACB1 Calibration Byte 1
                DACB1GAINCAL: u8,
                padding: [16]u8,
            };
        };

        pub const SLEEP = extern struct {
            /// Sleep Mode
            pub const SLEEP_SMODE = enum(u3) {
                /// Idle mode
                IDLE = 0x0,
                /// Power-down Mode
                PDOWN = 0x2,
                /// Power-save Mode
                PSAVE = 0x3,
                /// Standby Mode
                STDBY = 0x6,
                /// Extended Standby Mode
                ESTDBY = 0x7,
                _,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Sleep Enable
                SEN: u1,
                /// Sleep Mode
                SMODE: SLEEP_SMODE,
                padding: u4,
            }),
        };

        pub const SPI = extern struct {
            /// Interrupt level
            pub const SPI_INTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// SPI Mode
            pub const SPI_MODE = enum(u2) {
                /// SPI Mode 0
                @"0" = 0x0,
                /// SPI Mode 1
                @"1" = 0x1,
                /// SPI Mode 2
                @"2" = 0x2,
                /// SPI Mode 3
                @"3" = 0x3,
            };

            /// Prescaler setting
            pub const SPI_PRESCALER = enum(u2) {
                /// System Clock / 4
                DIV4 = 0x0,
                /// System Clock / 16
                DIV16 = 0x1,
                /// System Clock / 64
                DIV64 = 0x2,
                /// System Clock / 128
                DIV128 = 0x3,
            };

            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Prescaler
                PRESCALER: SPI_PRESCALER,
                /// SPI Mode
                MODE: SPI_MODE,
                /// Master Operation Enable
                MASTER: u1,
                /// Data Order Setting
                DORD: u1,
                /// Enable Module
                ENABLE: u1,
                /// Enable Double Speed
                CLK2X: u1,
            }),
            /// Interrupt Control Register
            INTCTRL: mmio.Mmio(packed struct(u8) {
                /// Interrupt level
                INTLVL: SPI_INTLVL,
                padding: u6,
            }),
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                reserved6: u6,
                /// Write Collision
                WRCOL: u1,
                /// Interrupt Flag
                IF: u1,
            }),
            /// Data Register
            DATA: u8,
        };

        pub const TC = struct {
            /// Byte Mode
            pub const TC_BYTEM = enum(u2) {
                /// 16-bit mode
                NORMAL = 0x0,
                /// Timer/Counter operating in byte mode only
                BYTEMODE = 0x1,
                /// Timer/Counter split into two 8-bit Counters (TC2)
                SPLITMODE = 0x2,
                _,
            };

            /// Compare or Capture A Interrupt Level
            pub const TC_CCAINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Compare or Capture B Interrupt Level
            pub const TC_CCBINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Compare or Capture C Interrupt Level
            pub const TC_CCCINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Compare or Capture D Interrupt Level
            pub const TC_CCDINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Clock Selection
            pub const TC_CLKSEL = enum(u4) {
                /// Timer Off
                OFF = 0x0,
                /// System Clock
                DIV1 = 0x1,
                /// System Clock / 2
                DIV2 = 0x2,
                /// System Clock / 4
                DIV4 = 0x3,
                /// System Clock / 8
                DIV8 = 0x4,
                /// System Clock / 64
                DIV64 = 0x5,
                /// System Clock / 256
                DIV256 = 0x6,
                /// System Clock / 1024
                DIV1024 = 0x7,
                /// Event Channel 0
                EVCH0 = 0x8,
                /// Event Channel 1
                EVCH1 = 0x9,
                /// Event Channel 2
                EVCH2 = 0xa,
                /// Event Channel 3
                EVCH3 = 0xb,
                /// Event Channel 4
                EVCH4 = 0xc,
                /// Event Channel 5
                EVCH5 = 0xd,
                /// Event Channel 6
                EVCH6 = 0xe,
                /// Event Channel 7
                EVCH7 = 0xf,
            };

            /// Timer/Counter Command
            pub const TC_CMD = enum(u2) {
                /// No Command
                NONE = 0x0,
                /// Force Update
                UPDATE = 0x1,
                /// Force Restart
                RESTART = 0x2,
                /// Force Hard Reset
                RESET = 0x3,
            };

            /// Error Interrupt Level
            pub const TC_ERRINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Event Action
            pub const TC_EVACT = enum(u3) {
                /// No Event Action
                OFF = 0x0,
                /// Input Capture
                CAPT = 0x1,
                /// Externally Controlled Up/Down Count
                UPDOWN = 0x2,
                /// Quadrature Decode
                QDEC = 0x3,
                /// Restart
                RESTART = 0x4,
                /// Frequency Capture
                FRQ = 0x5,
                /// Pulse-width Capture
                PW = 0x6,
                _,
            };

            /// Event Selection
            pub const TC_EVSEL = enum(u4) {
                /// No Event Source
                OFF = 0x0,
                /// Event Channel 0
                CH0 = 0x8,
                /// Event Channel 1
                CH1 = 0x9,
                /// Event Channel 2
                CH2 = 0xa,
                /// Event Channel 3
                CH3 = 0xb,
                /// Event Channel 4
                CH4 = 0xc,
                /// Event Channel 5
                CH5 = 0xd,
                /// Event Channel 6
                CH6 = 0xe,
                /// Event Channel 7
                CH7 = 0xf,
                _,
            };

            /// Overflow Interrupt Level
            pub const TC_OVFINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Waveform Generation Mode
            pub const TC_WGMODE = enum(u3) {
                /// Normal Mode
                NORMAL = 0x0,
                /// Frequency Generation Mode
                FRQ = 0x1,
                /// Single Slope
                SINGLESLOPE = 0x3,
                /// Dual Slope, Update on TOP
                DSTOP = 0x5,
                /// Dual Slope, Update on both TOP and BOTTOM
                DSBOTH = 0x6,
                /// Dual Slope, Update on BOTTOM
                DSBOTTOM = 0x7,
                _,
            };

            /// 16-bit Timer/Counter 0
            pub const TC0 = extern struct {
                /// Control Register A
                CTRLA: u8,
                /// Control Register B
                CTRLB: mmio.Mmio(packed struct(u8) {
                    reserved4: u4,
                    /// Compare or Capture A Enable
                    CCAEN: u1,
                    /// Compare or Capture B Enable
                    CCBEN: u1,
                    /// Compare or Capture C Enable
                    CCCEN: u1,
                    /// Compare or Capture D Enable
                    CCDEN: u1,
                }),
                /// Control register C
                CTRLC: mmio.Mmio(packed struct(u8) {
                    /// Compare A Output Value
                    CMPA: u1,
                    /// Compare B Output Value
                    CMPB: u1,
                    /// Compare C Output Value
                    CMPC: u1,
                    /// Compare D Output Value
                    CMPD: u1,
                    padding: u4,
                }),
                /// Control Register D
                CTRLD: mmio.Mmio(packed struct(u8) {
                    reserved4: u4,
                    /// Event Delay
                    EVDLY: u1,
                    padding: u3,
                }),
                /// Control Register E
                CTRLE: u8,
                reserved6: [1]u8,
                /// Interrupt Control Register A
                INTCTRLA: u8,
                /// Interrupt Control Register B
                INTCTRLB: u8,
                /// Control Register F Clear
                CTRLFCLR: mmio.Mmio(packed struct(u8) {
                    /// Direction
                    DIR: u1,
                    /// Lock Update
                    LUPD: u1,
                    /// Command
                    CMD: u2,
                    padding: u4,
                }),
                /// Control Register F Set
                CTRLFSET: mmio.Mmio(packed struct(u8) {
                    /// Direction
                    DIR: u1,
                    /// Lock Update
                    LUPD: u1,
                    padding: u6,
                }),
                /// Control Register G Clear
                CTRLGCLR: mmio.Mmio(packed struct(u8) {
                    /// Period Buffer Valid
                    PERBV: u1,
                    /// Compare or Capture A Buffer Valid
                    CCABV: u1,
                    /// Compare or Capture B Buffer Valid
                    CCBBV: u1,
                    /// Compare or Capture C Buffer Valid
                    CCCBV: u1,
                    /// Compare or Capture D Buffer Valid
                    CCDBV: u1,
                    padding: u3,
                }),
                /// Control Register G Set
                CTRLGSET: mmio.Mmio(packed struct(u8) {
                    /// Period Buffer Valid
                    PERBV: u1,
                    /// Compare or Capture A Buffer Valid
                    CCABV: u1,
                    /// Compare or Capture B Buffer Valid
                    CCBBV: u1,
                    /// Compare or Capture C Buffer Valid
                    CCCBV: u1,
                    /// Compare or Capture D Buffer Valid
                    CCDBV: u1,
                    padding: u3,
                }),
                /// Interrupt Flag Register
                INTFLAGS: mmio.Mmio(packed struct(u8) {
                    /// Overflow Interrupt Flag
                    OVFIF: u1,
                    /// Error Interrupt Flag
                    ERRIF: u1,
                    reserved4: u2,
                    /// Compare or Capture A Interrupt Flag
                    CCAIF: u1,
                    /// Compare or Capture B Interrupt Flag
                    CCBIF: u1,
                    /// Compare or Capture C Interrupt Flag
                    CCCIF: u1,
                    /// Compare or Capture D Interrupt Flag
                    CCDIF: u1,
                }),
                reserved15: [2]u8,
                /// Temporary Register For 16-bit Access
                TEMP: u8,
                reserved32: [16]u8,
                /// Count
                CNT: u16,
                reserved38: [4]u8,
                /// Period
                PER: u16,
                /// Compare or Capture A
                CCA: u16,
                /// Compare or Capture B
                CCB: u16,
                /// Compare or Capture C
                CCC: u16,
                /// Compare or Capture D
                CCD: u16,
                reserved54: [6]u8,
                /// Period Buffer
                PERBUF: u16,
                /// Compare Or Capture A Buffer
                CCABUF: u16,
                /// Compare Or Capture B Buffer
                CCBBUF: u16,
                /// Compare Or Capture C Buffer
                CCCBUF: u16,
                /// Compare Or Capture D Buffer
                CCDBUF: u16,
            };

            /// 16-bit Timer/Counter 1
            pub const TC1 = extern struct {
                /// Control Register A
                CTRLA: u8,
                /// Control Register B
                CTRLB: mmio.Mmio(packed struct(u8) {
                    reserved4: u4,
                    /// Compare or Capture A Enable
                    CCAEN: u1,
                    /// Compare or Capture B Enable
                    CCBEN: u1,
                    padding: u2,
                }),
                /// Control register C
                CTRLC: mmio.Mmio(packed struct(u8) {
                    /// Compare A Output Value
                    CMPA: u1,
                    /// Compare B Output Value
                    CMPB: u1,
                    padding: u6,
                }),
                /// Control Register D
                CTRLD: mmio.Mmio(packed struct(u8) {
                    reserved4: u4,
                    /// Event Delay
                    EVDLY: u1,
                    padding: u3,
                }),
                /// Control Register E
                CTRLE: mmio.Mmio(packed struct(u8) {
                    /// Byte Mode
                    BYTEM: u1,
                    padding: u7,
                }),
                reserved6: [1]u8,
                /// Interrupt Control Register A
                INTCTRLA: u8,
                /// Interrupt Control Register B
                INTCTRLB: u8,
                /// Control Register F Clear
                CTRLFCLR: mmio.Mmio(packed struct(u8) {
                    /// Direction
                    DIR: u1,
                    /// Lock Update
                    LUPD: u1,
                    /// Command
                    CMD: u2,
                    padding: u4,
                }),
                /// Control Register F Set
                CTRLFSET: mmio.Mmio(packed struct(u8) {
                    /// Direction
                    DIR: u1,
                    /// Lock Update
                    LUPD: u1,
                    padding: u6,
                }),
                /// Control Register G Clear
                CTRLGCLR: mmio.Mmio(packed struct(u8) {
                    /// Period Buffer Valid
                    PERBV: u1,
                    /// Compare or Capture A Buffer Valid
                    CCABV: u1,
                    /// Compare or Capture B Buffer Valid
                    CCBBV: u1,
                    padding: u5,
                }),
                /// Control Register G Set
                CTRLGSET: mmio.Mmio(packed struct(u8) {
                    /// Period Buffer Valid
                    PERBV: u1,
                    /// Compare or Capture A Buffer Valid
                    CCABV: u1,
                    /// Compare or Capture B Buffer Valid
                    CCBBV: u1,
                    padding: u5,
                }),
                /// Interrupt Flag Register
                INTFLAGS: mmio.Mmio(packed struct(u8) {
                    /// Overflow Interrupt Flag
                    OVFIF: u1,
                    /// Error Interrupt Flag
                    ERRIF: u1,
                    reserved4: u2,
                    /// Compare or Capture A Interrupt Flag
                    CCAIF: u1,
                    /// Compare or Capture B Interrupt Flag
                    CCBIF: u1,
                    padding: u2,
                }),
                reserved15: [2]u8,
                /// Temporary Register For 16-bit Access
                TEMP: u8,
                reserved32: [16]u8,
                /// Count
                CNT: u16,
                reserved38: [4]u8,
                /// Period
                PER: u16,
                /// Compare or Capture A
                CCA: u16,
                /// Compare or Capture B
                CCB: u16,
                reserved54: [10]u8,
                /// Period Buffer
                PERBUF: u16,
                /// Compare Or Capture A Buffer
                CCABUF: u16,
                /// Compare Or Capture B Buffer
                CCBBUF: u16,
            };
        };

        pub const TC2 = extern struct {
            /// Byte Mode
            pub const TC2_BYTEM = enum(u2) {
                /// 16-bit mode
                NORMAL = 0x0,
                /// Timer/Counter operating in byte mode only (TC2)
                BYTEMODE = 0x1,
                /// Timer/Counter split into two 8-bit Counters
                SPLITMODE = 0x2,
                _,
            };

            /// Clock Selection
            pub const TC2_CLKSEL = enum(u4) {
                /// Timer Off
                OFF = 0x0,
                /// System Clock
                DIV1 = 0x1,
                /// System Clock / 2
                DIV2 = 0x2,
                /// System Clock / 4
                DIV4 = 0x3,
                /// System Clock / 8
                DIV8 = 0x4,
                /// System Clock / 64
                DIV64 = 0x5,
                /// System Clock / 256
                DIV256 = 0x6,
                /// System Clock / 1024
                DIV1024 = 0x7,
                /// Event Channel 0
                EVCH0 = 0x8,
                /// Event Channel 1
                EVCH1 = 0x9,
                /// Event Channel 2
                EVCH2 = 0xa,
                /// Event Channel 3
                EVCH3 = 0xb,
                /// Event Channel 4
                EVCH4 = 0xc,
                /// Event Channel 5
                EVCH5 = 0xd,
                /// Event Channel 6
                EVCH6 = 0xe,
                /// Event Channel 7
                EVCH7 = 0xf,
            };

            /// Timer/Counter Command
            pub const TC2_CMD = enum(u2) {
                /// No Command
                NONE = 0x0,
                /// Force Restart
                RESTART = 0x2,
                /// Force Hard Reset
                RESET = 0x3,
                _,
            };

            /// Timer/Counter Command
            pub const TC2_CMDEN = enum(u2) {
                /// Low Byte Timer/Counter
                LOW = 0x1,
                /// High Byte Timer/Counter
                HIGH = 0x2,
                /// Both Low Byte and High Byte Timer/Counters
                BOTH = 0x3,
                _,
            };

            /// High Byte Underflow Interrupt Level
            pub const TC2_HUNFINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Low Byte Compare A Interrupt Level
            pub const TC2_LCMPAINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Low Byte Compare B Interrupt Level
            pub const TC2_LCMPBINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Low Byte Compare C Interrupt Level
            pub const TC2_LCMPCINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Low Byte Compare D Interrupt Level
            pub const TC2_LCMPDINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Low Byte Underflow Interrupt Level
            pub const TC2_LUNFINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Control Register A
            CTRLA: mmio.Mmio(packed struct(u8) {
                /// Clock Selection
                CLKSEL: TC2_CLKSEL,
                padding: u4,
            }),
            /// Control Register B
            CTRLB: mmio.Mmio(packed struct(u8) {
                /// Low Byte Compare A Enable
                LCMPAEN: u1,
                /// Low Byte Compare B Enable
                LCMPBEN: u1,
                /// Low Byte Compare C Enable
                LCMPCEN: u1,
                /// Low Byte Compare D Enable
                LCMPDEN: u1,
                /// High Byte Compare A Enable
                HCMPAEN: u1,
                /// High Byte Compare B Enable
                HCMPBEN: u1,
                /// High Byte Compare C Enable
                HCMPCEN: u1,
                /// High Byte Compare D Enable
                HCMPDEN: u1,
            }),
            /// Control register C
            CTRLC: mmio.Mmio(packed struct(u8) {
                /// Low Byte Compare A Output Value
                LCMPA: u1,
                /// Low Byte Compare B Output Value
                LCMPB: u1,
                /// Low Byte Compare C Output Value
                LCMPC: u1,
                /// Low Byte Compare D Output Value
                LCMPD: u1,
                /// High Byte Compare A Output Value
                HCMPA: u1,
                /// High Byte Compare B Output Value
                HCMPB: u1,
                /// High Byte Compare C Output Value
                HCMPC: u1,
                /// High Byte Compare D Output Value
                HCMPD: u1,
            }),
            reserved4: [1]u8,
            /// Control Register E
            CTRLE: mmio.Mmio(packed struct(u8) {
                /// Byte Mode
                BYTEM: TC2_BYTEM,
                padding: u6,
            }),
            reserved6: [1]u8,
            /// Interrupt Control Register A
            INTCTRLA: mmio.Mmio(packed struct(u8) {
                /// Low Byte Underflow interrupt level
                LUNFINTLVL: TC2_LUNFINTLVL,
                /// High Byte Underflow Interrupt Level
                HUNFINTLVL: TC2_HUNFINTLVL,
                padding: u4,
            }),
            /// Interrupt Control Register B
            INTCTRLB: mmio.Mmio(packed struct(u8) {
                /// Low Byte Compare A Interrupt Level
                LCMPAINTLVL: TC2_LCMPAINTLVL,
                /// Low Byte Compare B Interrupt Level
                LCMPBINTLVL: TC2_LCMPBINTLVL,
                /// Low Byte Compare C Interrupt Level
                LCMPCINTLVL: TC2_LCMPCINTLVL,
                /// Low Byte Compare D Interrupt Level
                LCMPDINTLVL: TC2_LCMPDINTLVL,
            }),
            reserved9: [1]u8,
            /// Control Register F
            CTRLF: mmio.Mmio(packed struct(u8) {
                /// Command Enable
                CMDEN: TC2_CMDEN,
                /// Command
                CMD: TC2_CMD,
                padding: u4,
            }),
            reserved12: [2]u8,
            /// Interrupt Flag Register
            INTFLAGS: mmio.Mmio(packed struct(u8) {
                /// Low Byte Underflow Interrupt Flag
                LUNFIF: u1,
                /// High Byte Underflow Interrupt Flag
                HUNFIF: u1,
                reserved4: u2,
                /// Low Byte Compare A Interrupt Flag
                LCMPAIF: u1,
                /// Low Byte Compare B Interrupt Flag
                LCMPBIF: u1,
                /// Low Byte Compare C Interrupt Flag
                LCMPCIF: u1,
                /// Low Byte Compare D Interrupt Flag
                LCMPDIF: u1,
            }),
            reserved32: [19]u8,
            /// Low Byte Count
            LCNT: u8,
            /// High Byte Count
            HCNT: u8,
            reserved38: [4]u8,
            /// Low Byte Period
            LPER: u8,
            /// High Byte Period
            HPER: u8,
            /// Low Byte Compare A
            LCMPA: u8,
            /// High Byte Compare A
            HCMPA: u8,
            /// Low Byte Compare B
            LCMPB: u8,
            /// High Byte Compare B
            HCMPB: u8,
            /// Low Byte Compare C
            LCMPC: u8,
            /// High Byte Compare C
            HCMPC: u8,
            /// Low Byte Compare D
            LCMPD: u8,
            /// High Byte Compare D
            HCMPD: u8,
        };

        pub const TWI = struct {
            /// Master Bus State
            pub const TWI_MASTER_BUSSTATE = enum(u2) {
                /// Unknown Bus State
                UNKNOWN = 0x0,
                /// Bus is Idle
                IDLE = 0x1,
                /// This Module Controls The Bus
                OWNER = 0x2,
                /// The Bus is Busy
                BUSY = 0x3,
            };

            /// Master Command
            pub const TWI_MASTER_CMD = enum(u2) {
                /// No Action
                NOACT = 0x0,
                /// Issue Repeated Start Condition
                REPSTART = 0x1,
                /// Receive or Transmit Data
                RECVTRANS = 0x2,
                /// Issue Stop Condition
                STOP = 0x3,
            };

            /// Master Interrupt Level
            pub const TWI_MASTER_INTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Inactive Timeout
            pub const TWI_MASTER_TIMEOUT = enum(u2) {
                /// Bus Timeout Disabled
                DISABLED = 0x0,
                /// 50 Microseconds
                @"50US" = 0x1,
                /// 100 Microseconds
                @"100US" = 0x2,
                /// 200 Microseconds
                @"200US" = 0x3,
            };

            /// SDA Hold Time
            pub const TWI_SDAHOLD = enum(u2) {
                /// SDA Hold Time off
                OFF = 0x0,
                /// SDA Hold Time 50 ns
                @"50NS" = 0x1,
                /// SDA Hold Time 300 ns
                @"300NS" = 0x2,
                /// SDA Hold Time 400 ns
                @"400NS" = 0x3,
            };

            /// Slave Command
            pub const TWI_SLAVE_CMD = enum(u2) {
                /// No Action
                NOACT = 0x0,
                /// Used To Complete a Transaction
                COMPTRANS = 0x2,
                /// Used in Response to Address/Data Interrupt
                RESPONSE = 0x3,
                _,
            };

            /// Slave Interrupt Level
            pub const TWI_SLAVE_INTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Two-Wire Interface
            pub const TWI = extern struct {
                /// TWI Common Control Register
                CTRL: mmio.Mmio(packed struct(u8) {
                    /// External Driver Interface Enable
                    EDIEN: u1,
                    padding: u7,
                }),
                padding: [13]u8,
            };

            pub const TWI_MASTER = extern struct {
                /// Control Register A
                CTRLA: mmio.Mmio(packed struct(u8) {
                    reserved3: u3,
                    /// Enable TWI Master
                    ENABLE: u1,
                    /// Write Interrupt Enable
                    WIEN: u1,
                    /// Read Interrupt Enable
                    RIEN: u1,
                    padding: u2,
                }),
                /// Control Register B
                CTRLB: mmio.Mmio(packed struct(u8) {
                    /// Smart Mode Enable
                    SMEN: u1,
                    /// Quick Command Enable
                    QCEN: u1,
                    padding: u6,
                }),
                /// Control Register C
                CTRLC: mmio.Mmio(packed struct(u8) {
                    reserved2: u2,
                    /// Acknowledge Action
                    ACKACT: u1,
                    padding: u5,
                }),
                /// Status Register
                STATUS: mmio.Mmio(packed struct(u8) {
                    reserved2: u2,
                    /// Bus Error
                    BUSERR: u1,
                    /// Arbitration Lost
                    ARBLOST: u1,
                    /// Received Acknowledge
                    RXACK: u1,
                    /// Clock Hold
                    CLKHOLD: u1,
                    /// Write Interrupt Flag
                    WIF: u1,
                    /// Read Interrupt Flag
                    RIF: u1,
                }),
                /// Baud Rate Control Register
                BAUD: u8,
                /// Address Register
                ADDR: u8,
                /// Data Register
                DATA: u8,
            };

            pub const TWI_SLAVE = extern struct {
                /// Control Register A
                CTRLA: mmio.Mmio(packed struct(u8) {
                    /// Smart Mode Enable
                    SMEN: u1,
                    /// Promiscuous Mode Enable
                    PMEN: u1,
                    /// Stop Interrupt Enable
                    PIEN: u1,
                    /// Enable TWI Slave
                    ENABLE: u1,
                    /// Address/Stop Interrupt Enable
                    APIEN: u1,
                    /// Data Interrupt Enable
                    DIEN: u1,
                    padding: u2,
                }),
                /// Control Register B
                CTRLB: mmio.Mmio(packed struct(u8) {
                    reserved2: u2,
                    /// Acknowledge Action
                    ACKACT: u1,
                    padding: u5,
                }),
                /// Status Register
                STATUS: mmio.Mmio(packed struct(u8) {
                    /// Slave Address or Stop
                    AP: u1,
                    /// Read/Write Direction
                    DIR: u1,
                    /// Bus Error
                    BUSERR: u1,
                    /// Collision
                    COLL: u1,
                    /// Received Acknowledge
                    RXACK: u1,
                    /// Clock Hold
                    CLKHOLD: u1,
                    /// Address/Stop Interrupt Flag
                    APIF: u1,
                    /// Data Interrupt Flag
                    DIF: u1,
                }),
                /// Address Register
                ADDR: u8,
                /// Data Register
                DATA: u8,
                /// Address Mask Register
                ADDRMASK: mmio.Mmio(packed struct(u8) {
                    /// Address Enable
                    ADDREN: u1,
                    /// Address Mask
                    ADDRMASK: u7,
                }),
            };
        };

        pub const USART = extern struct {
            /// Character Size
            pub const USART_CHSIZE = enum(u3) {
                /// Character size: 5 bit
                @"5BIT" = 0x0,
                /// Character size: 6 bit
                @"6BIT" = 0x1,
                /// Character size: 7 bit
                @"7BIT" = 0x2,
                /// Character size: 8 bit
                @"8BIT" = 0x3,
                /// Character size: 9 bit
                @"9BIT" = 0x7,
                _,
            };

            /// Communication Mode
            pub const USART_CMODE = enum(u2) {
                /// Asynchronous Mode
                ASYNCHRONOUS = 0x0,
                /// Synchronous Mode
                SYNCHRONOUS = 0x1,
                /// IrDA Mode
                IRDA = 0x2,
                /// Master SPI Mode
                MSPI = 0x3,
            };

            /// Data Register Empty Interrupt level
            pub const USART_DREINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Parity Mode
            pub const USART_PMODE = enum(u2) {
                /// No Parity
                DISABLED = 0x0,
                /// Even Parity
                EVEN = 0x2,
                /// Odd Parity
                ODD = 0x3,
                _,
            };

            /// Receive Complete Interrupt level
            pub const USART_RXCINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Transmit Complete Interrupt level
            pub const USART_TXCINTLVL = enum(u2) {
                /// Interrupt Disabled
                OFF = 0x0,
                /// Low Level
                LO = 0x1,
                /// Medium Level
                MED = 0x2,
                /// High Level
                HI = 0x3,
            };

            /// Data Register
            DATA: u8,
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Receive Bit 8
                RXB8: u1,
                reserved2: u1,
                /// Parity Error
                PERR: u1,
                /// Buffer Overflow
                BUFOVF: u1,
                /// Frame Error
                FERR: u1,
                /// Data Register Empty Flag
                DREIF: u1,
                /// Transmit Interrupt Flag
                TXCIF: u1,
                /// Receive Interrupt Flag
                RXCIF: u1,
            }),
            reserved3: [1]u8,
            /// Control Register A
            CTRLA: mmio.Mmio(packed struct(u8) {
                /// Data Register Empty Interrupt Level
                DREINTLVL: USART_DREINTLVL,
                /// Transmit Interrupt Level
                TXCINTLVL: USART_TXCINTLVL,
                /// Receive Interrupt Level
                RXCINTLVL: USART_RXCINTLVL,
                padding: u2,
            }),
            /// Control Register B
            CTRLB: mmio.Mmio(packed struct(u8) {
                /// Transmit bit 8
                TXB8: u1,
                /// Multi-processor Communication Mode
                MPCM: u1,
                /// Double transmission speed
                CLK2X: u1,
                /// Transmitter Enable
                TXEN: u1,
                /// Receiver Enable
                RXEN: u1,
                padding: u3,
            }),
            /// Control Register C
            CTRLC: mmio.Mmio(packed struct(u8) {
                /// Character Size
                CHSIZE: USART_CHSIZE,
                /// Stop Bit Mode
                SBMODE: u1,
                /// Parity Mode
                PMODE: USART_PMODE,
                /// Communication Mode
                CMODE: USART_CMODE,
            }),
            /// Baud Rate Control Register A
            BAUDCTRLA: mmio.Mmio(packed struct(u8) {
                /// Baud Rate Selection Bits [7:0]
                BSEL: u8,
            }),
            /// Baud Rate Control Register B
            BAUDCTRLB: mmio.Mmio(packed struct(u8) {
                /// Baud Rate Selection bits[11:8]
                BSEL: u4,
                /// Baud Rate Scale
                BSCALE: u4,
            }),
        };

        pub const USB = struct {
            /// USB Endpoint Buffersize
            pub const USB_EP_BUFSIZE = enum(u3) {
                /// 8 bytes buffer size
                @"8" = 0x0,
                /// 16 bytes buffer size
                @"16" = 0x1,
                /// 32 bytes buffer size
                @"32" = 0x2,
                /// 64 bytes buffer size
                @"64" = 0x3,
                /// 128 bytes buffer size
                @"128" = 0x4,
                /// 256 bytes buffer size
                @"256" = 0x5,
                /// 512 bytes buffer size
                @"512" = 0x6,
                /// 1023 bytes buffer size
                @"1023" = 0x7,
            };

            /// USB Endpoint Type
            pub const USB_EP_TYPE = enum(u2) {
                /// Endpoint Disabled
                DISABLE = 0x0,
                /// Control
                CONTROL = 0x1,
                /// Bulk/Interrupt
                BULK = 0x2,
                /// Isochronous
                ISOCHRONOUS = 0x3,
            };

            /// Interrupt level
            pub const USB_INTLVL = enum(u2) {
                /// Interrupt disabled
                OFF = 0x0,
                /// Low level
                LO = 0x1,
                /// Medium level
                MED = 0x2,
                /// High level
                HI = 0x3,
            };

            /// Universal Serial Bus
            pub const USB = extern struct {
                /// Control Register A
                CTRLA: mmio.Mmio(packed struct(u8) {
                    /// Maximum Endpoint Addresses
                    MAXEP: u4,
                    /// Store Frame Number Enable
                    STFRNUM: u1,
                    /// USB FIFO Enable
                    FIFOEN: u1,
                    /// Speed Select
                    SPEED: u1,
                    /// USB Enable
                    ENABLE: u1,
                }),
                /// Control Register B
                CTRLB: mmio.Mmio(packed struct(u8) {
                    /// Attach
                    ATTACH: u1,
                    /// Global NACK
                    GNACK: u1,
                    /// Remote Wake-up
                    RWAKEUP: u1,
                    reserved4: u1,
                    /// Pull during Reset
                    PULLRST: u1,
                    padding: u3,
                }),
                /// Status Register
                STATUS: mmio.Mmio(packed struct(u8) {
                    /// Bus Reset
                    BUSRST: u1,
                    /// Bus Suspended
                    SUSPEND: u1,
                    /// Resume
                    RESUME: u1,
                    /// Upstream Resume
                    URESUME: u1,
                    padding: u4,
                }),
                /// Address Register
                ADDR: mmio.Mmio(packed struct(u8) {
                    /// Device Address
                    ADDR: u7,
                    padding: u1,
                }),
                /// FIFO Write Pointer Register
                FIFOWP: mmio.Mmio(packed struct(u8) {
                    /// FIFO Write Pointer
                    FIFOWP: u5,
                    padding: u3,
                }),
                /// FIFO Read Pointer Register
                FIFORP: mmio.Mmio(packed struct(u8) {
                    /// FIFO Read Pointer
                    FIFORP: u5,
                    padding: u3,
                }),
                /// Endpoint Configuration Table Pointer
                EPPTR: u16,
                /// Interrupt Control Register A
                INTCTRLA: mmio.Mmio(packed struct(u8) {
                    reserved4: u4,
                    /// STALL Interrupt Enable
                    STALLIE: u1,
                    /// Bus Error Interrupt Enable
                    BUSERRIE: u1,
                    /// Bus Event Interrupt Enable
                    BUSEVIE: u1,
                    /// Start Of Frame Interrupt Enable
                    SOFIE: u1,
                }),
                /// Interrupt Control Register B
                INTCTRLB: mmio.Mmio(packed struct(u8) {
                    /// SETUP Transaction Complete Interrupt Enable
                    SETUPIE: u1,
                    /// Transaction Complete Interrupt Enable
                    TRNIE: u1,
                    padding: u6,
                }),
                /// Clear Interrupt Flag Register A
                INTFLAGSACLR: mmio.Mmio(packed struct(u8) {
                    /// STALL Interrupt Flag
                    STALLIF: u1,
                    /// Overflow Interrupt Flag
                    OVFIF: u1,
                    /// Underflow Interrupt Flag
                    UNFIF: u1,
                    /// Isochronous CRC Error Interrupt Flag
                    CRCIF: u1,
                    /// Reset Interrupt Flag
                    RSTIF: u1,
                    /// Resume Interrupt Flag
                    RESUMEIF: u1,
                    /// Suspend Interrupt Flag
                    SUSPENDIF: u1,
                    /// Start Of Frame Interrupt Flag
                    SOFIF: u1,
                }),
                /// Set Interrupt Flag Register A
                INTFLAGSASET: mmio.Mmio(packed struct(u8) {
                    /// STALL Interrupt Flag
                    STALLIF: u1,
                    /// Overflow Interrupt Flag
                    OVFIF: u1,
                    /// Underflow Interrupt Flag
                    UNFIF: u1,
                    /// Isochronous CRC Error Interrupt Flag
                    CRCIF: u1,
                    /// Reset Interrupt Flag
                    RSTIF: u1,
                    /// Resume Interrupt Flag
                    RESUMEIF: u1,
                    /// Suspend Interrupt Flag
                    SUSPENDIF: u1,
                    /// Start Of Frame Interrupt Flag
                    SOFIF: u1,
                }),
                /// Clear Interrupt Flag Register B
                INTFLAGSBCLR: mmio.Mmio(packed struct(u8) {
                    /// SETUP Transaction Complete Interrupt Flag
                    SETUPIF: u1,
                    /// Transaction Complete Interrupt Flag
                    TRNIF: u1,
                    padding: u6,
                }),
                /// Set Interrupt Flag Register B
                INTFLAGSBSET: mmio.Mmio(packed struct(u8) {
                    /// SETUP Transaction Complete Interrupt Flag
                    SETUPIF: u1,
                    /// Transaction Complete Interrupt Flag
                    TRNIF: u1,
                    padding: u6,
                }),
                reserved58: [44]u8,
                /// Calibration Byte 0
                CAL0: u8,
                /// Calibration Byte 1
                CAL1: u8,
            };

            /// USB Endpoint
            pub const USB_EP = extern struct {
                /// Endpoint Status
                STATUS: mmio.Mmio(packed struct(u8) {
                    /// Data Toggle
                    TOGGLE: u1,
                    /// Data Buffer 0 Not Acknowledge
                    BUSNACK0: u1,
                    /// Data Buffer 1 Not Acknowledge
                    BUSNACK1: u1,
                    /// Bank Select
                    BANK: u1,
                    /// Transaction Complete 1 Flag
                    TRNCOMPL1: u1,
                    /// Transaction Complete 0 Flag
                    TRNCOMPL0: u1,
                    /// Underflow Enpoint FLag
                    UNF: u1,
                    /// Endpoint Stall Flag
                    STALLF: u1,
                }),
                /// Endpoint Control
                CTRL: mmio.Mmio(packed struct(u8) {
                    reserved2: u2,
                    /// Data Stall
                    STALL: u1,
                    /// Interrupt Disable
                    INTDSBL: u1,
                    /// Ping-Pong Enable
                    PINGPONG: u1,
                    /// Multi Packet Transfer Enable
                    MULTIPKT: u1,
                    padding: u2,
                }),
                /// USB Endpoint Counter
                CNT: mmio.Mmio(packed struct(u16) {
                    reserved15: u15,
                    /// Zero Length Packet
                    ZLP: u1,
                }),
                /// Data Pointer
                DATAPTR: u16,
                /// Auxiliary Data
                AUXDATA: u16,
            };

            /// USB Endpoint Table
            pub const USB_EP_TABLE = extern struct {
                /// Frame Number Low Byte
                FRAMENUML: u8,
                /// Frame Number High Byte
                FRAMENUMH: u8,
                padding: [272]u8,
            };
        };

        pub const VBAT = extern struct {
            /// Control Register
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Reset
                RESET: u1,
                /// Access Enable
                ACCEN: u1,
                /// Crystal Oscillator Failure Detection Monitor Enable
                XOSCFDEN: u1,
                /// Crystal Oscillator Enable
                XOSCEN: u1,
                /// 32-kHz Crystal Oscillator Output Selection
                XOSCSEL: u1,
                /// 32-kHz Crystal Oscillator High Power Mode
                HIGHESR: u1,
                padding: u2,
            }),
            /// Status Register
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Battery Backup Power-On Reset Flag
                BBPORF: u1,
                /// Battery Backup Brown-Out Reset Flag
                BBBORF: u1,
                /// Crystal Oscillator Failure
                XOSCFAIL: u1,
                /// Crystal Oscillator Ready
                XOSCRDY: u1,
                reserved7: u3,
                /// Battery backup Power
                BBPWR: u1,
            }),
            /// Backup Register 0
            BACKUP0: u8,
            /// Backup Register 1
            BACKUP1: u8,
        };

        pub const VPORT = extern struct {
            /// I/O Port Data Direction
            DIR: u8,
            /// I/O Port Output
            OUT: u8,
            /// I/O Port Input
            IN: u8,
            /// Interrupt Flag Register
            INTFLAGS: mmio.Mmio(packed struct(u8) {
                /// Port Interrupt 0 Flag
                INT0IF: u1,
                /// Port Interrupt 1 Flag
                INT1IF: u1,
                padding: u6,
            }),
        };

        pub const WDT = extern struct {
            /// Period setting
            pub const WDT_PER = enum(u4) {
                /// 8 cycles (8ms @ 3.3V)
                @"8CLK" = 0x0,
                /// 16 cycles (16ms @ 3.3V)
                @"16CLK" = 0x1,
                /// 32 cycles (32ms @ 3.3V)
                @"32CLK" = 0x2,
                /// 64 cycles (64ms @ 3.3V)
                @"64CLK" = 0x3,
                /// 128 cycles (0.128s @ 3.3V)
                @"128CLK" = 0x4,
                /// 256 cycles (0.256s @ 3.3V)
                @"256CLK" = 0x5,
                /// 512 cycles (0.512s @ 3.3V)
                @"512CLK" = 0x6,
                /// 1K cycles (1s @ 3.3V)
                @"1KCLK" = 0x7,
                /// 2K cycles (2s @ 3.3V)
                @"2KCLK" = 0x8,
                /// 4K cycles (4s @ 3.3V)
                @"4KCLK" = 0x9,
                /// 8K cycles (8s @ 3.3V)
                @"8KCLK" = 0xa,
                _,
            };

            /// Closed window period
            pub const WDT_WPER = enum(u4) {
                /// 8 cycles (8ms @ 3.3V)
                @"8CLK" = 0x0,
                /// 16 cycles (16ms @ 3.3V)
                @"16CLK" = 0x1,
                /// 32 cycles (32ms @ 3.3V)
                @"32CLK" = 0x2,
                /// 64 cycles (64ms @ 3.3V)
                @"64CLK" = 0x3,
                /// 128 cycles (0.128s @ 3.3V)
                @"128CLK" = 0x4,
                /// 256 cycles (0.256s @ 3.3V)
                @"256CLK" = 0x5,
                /// 512 cycles (0.512s @ 3.3V)
                @"512CLK" = 0x6,
                /// 1K cycles (1s @ 3.3V)
                @"1KCLK" = 0x7,
                /// 2K cycles (2s @ 3.3V)
                @"2KCLK" = 0x8,
                /// 4K cycles (4s @ 3.3V)
                @"4KCLK" = 0x9,
                /// 8K cycles (8s @ 3.3V)
                @"8KCLK" = 0xa,
                _,
            };

            /// Control
            CTRL: mmio.Mmio(packed struct(u8) {
                /// Change Enable
                CEN: u1,
                /// Enable
                ENABLE: u1,
                /// Period
                PER: WDT_PER,
                padding: u2,
            }),
            /// Windowed Mode Control
            WINCTRL: mmio.Mmio(packed struct(u8) {
                /// Windowed Mode Change Enable
                WCEN: u1,
                /// Windowed Mode Enable
                WEN: u1,
                /// Windowed Mode Period
                WPER: WDT_WPER,
                padding: u2,
            }),
            /// Status
            STATUS: mmio.Mmio(packed struct(u8) {
                /// Syncronization busy
                SYNCBUSY: u1,
                padding: u7,
            }),
        };

        pub const XOCD = struct {
            /// On-Chip Debug System
            pub const OCD = extern struct {
                /// OCD Register 0
                OCDR0: mmio.Mmio(packed struct(u8) {
                    /// OCDR Dirty
                    OCDRD: u8,
                }),
                /// OCD Register 1
                OCDR1: mmio.Mmio(packed struct(u8) {
                    /// OCDR Dirty
                    OCDRD: u1,
                    padding: u7,
                }),
            };
        };
    };
};
